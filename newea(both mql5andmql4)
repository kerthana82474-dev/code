mql5 : //+------------------------------------------------------------------+
//|                                    XAUUSD_Adaptive_MDAE_EA.mq5 |
//|                                       Production-Ready MT5 Code |
//|                     Full Implementation with All Toggles & Logic |
//+------------------------------------------------------------------+
#property copyright "XAUUSD Adaptive MDAE System"
#property version   "1.00"
#property strict

#include <Trade\Trade.mqh>

//+------------------------------------------------------------------+
//| ENUMERATIONS                                                      |
//+------------------------------------------------------------------+
enum ENUM_REGIME
{
   REGIME_NO_TRADE = 0,
   REGIME_TREND_EXPANSION = 1,
   REGIME_MEAN_REVERSION = 2
};

enum ENUM_CLOSE_METHOD
{
   CM_FIXED = 1,
   CM_ATR_TRAIL = 2,
   CM_STRUCTURE_TRAIL = 3,
   CM_FAST_BANK = 4,
   CM_INVALIDATION_EXIT = 5,
   CM_HYBRID = 6
};

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - MASTER TOGGLES                                |
//+------------------------------------------------------------------+
input group "========== MASTER TOGGLES =========="
input bool InpEnableEA = true;                        // Enable EA
input bool InpEnableEntries = true;                   // Enable New Entries
input bool InpEnablePositionManagement = true;        // Enable Position Management
input bool InpEnableLogging = true;                   // Enable Logging
input bool InpEnableDebugPrints = false;              // Enable Debug Prints

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - REGIME & ENTRY TOGGLES                        |
//+------------------------------------------------------------------+
input group "========== REGIME & ENTRY TOGGLES =========="
input bool InpEnableRegimeEngine = true;              // Enable Regime Detection
input bool InpEnableTrendModule = true;               // Enable Trend Entry Module
input bool InpEnableMeanReversionModule = true;       // Enable Mean Reversion Module
input bool InpEnableNoTradeState = true;              // Enable NO_TRADE State
input bool InpEnableMTFContextCheck = true;           // Enable MTF Context Check
input bool InpEnableVWAPCheck = false;                // Enable VWAP Check (fallback)
input bool InpEnableSessionFilter = true;             // Enable Session Filter
input bool InpEnableNewsWindowBlock = false;          // Enable News Window Block

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - RISK & EXECUTION TOGGLES                      |
//+------------------------------------------------------------------+
input group "========== RISK & EXECUTION TOGGLES =========="
input bool InpEnableRiskGovernor = true;              // Enable Risk Governor
input bool InpEnableDailyDDLock = true;               // Enable Daily DD Lock
input bool InpEnableWeeklyDDLock = false;             // Enable Weekly DD Lock
input bool InpEnableConsecutiveLossLock = true;       // Enable Consecutive Loss Lock
input bool InpEnableSpreadEntryFilter = true;         // Enable Spread Entry Filter
input bool InpEnableSlippageEntryFilter = false;      // Enable Slippage Entry Filter
input bool InpEnableOnePositionOnly = true;           // Enable One Position Only
input bool InpEnableMaxTradesPerSession = true;       // Enable Max Trades Per Session

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - MDAE FEATURE TOGGLES                          |
//+------------------------------------------------------------------+
input group "========== MDAE FEATURE TOGGLES =========="
input bool InpEnableMDAE = true;                      // Enable MDAE System
input bool InpEnablePipsPerSecond = true;             // Enable Pips/Second Analysis
input bool InpEnableVolumePulse = true;               // Enable Volume Pulse Analysis
input bool InpEnableBodyExpansion = true;             // Enable Body Expansion Check
input bool InpEnableTop2BreakoutCheck = true;         // Enable Top2 Breakout Check
input bool InpEnableLowVolumeBox = true;              // Enable Low Volume Box
input bool InpEnableFibGuidance = false;              // Enable Fib Guidance
input bool InpEnableEntropyScoring = true;            // Enable Entropy Scoring
input bool InpEnablePolicySwitching = true;           // Enable Policy Switching

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - EXIT & ACTION TOGGLES                         |
//+------------------------------------------------------------------+
input group "========== EXIT & ACTION TOGGLES =========="
input bool InpEnablePartialClose = true;              // Enable Partial Close
input bool InpEnableBreakEven = true;                 // Enable Break Even
input bool InpEnableATRTrail = true;                  // Enable ATR Trailing
input bool InpEnableSwingTrail = true;                // Enable Swing Trailing
input bool InpEnableFastBankMode = true;              // Enable Fast Bank Mode
input bool InpEnableHybridCloseMode = true;           // Enable Hybrid Close Mode
input bool InpEnableInvalidationExit = true;          // Enable Invalidation Exit
input bool InpEnableTimeStop = true;                  // Enable Time Stop

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - COMPLIANCE TOGGLES (CRITICAL)                 |
//+------------------------------------------------------------------+
input group "========== COMPLIANCE TOGGLES (CRITICAL) =========="
input bool InpEnforceNoSpreadSlStopMoves = true;      // Enforce No Spread-Based SL Moves
input bool InpEnforceNoSlippageStopMoves = true;      // Enforce No Slippage-Based SL Moves
input bool InpEnableComplianceAuditCounters = true;   // Enable Compliance Audit Counters

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - CORE SETTINGS                                 |
//+------------------------------------------------------------------+
input group "========== CORE SETTINGS =========="
input string InpSymbol = "XAUUSD";                    // Trading Symbol
input int InpMagicNumber = 220262;                    // Magic Number
input double InpRiskPercent = 0.5;                    // Risk Per Trade (%)
input int InpMaxTradesPerDay = 3;                     // Max Trades Per Day

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - INDICATOR SETTINGS                            |
//+------------------------------------------------------------------+
input group "========== INDICATOR SETTINGS =========="
input int InpATRPeriod = 14;                          // ATR Period
input int InpADXPeriod = 14;                          // ADX Period
input int InpRSIPeriod = 14;                          // RSI Period
input int InpEMAFastPeriod = 20;                      // EMA Fast Period
input int InpEMASlowPeriod = 50;                      // EMA Slow Period
input int InpBBPeriod = 20;                           // Bollinger Bands Period
input double InpBBDeviation = 2.0;                    // Bollinger Bands Deviation

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - REGIME THRESHOLDS                             |
//+------------------------------------------------------------------+
input group "========== REGIME THRESHOLDS =========="
input double InpADXTrendThreshold = 25.0;             // ADX Trend Threshold
input double InpADXRangeThreshold = 20.0;             // ADX Range Threshold
input double InpBBWidthExpansionThreshold = 0.015;    // BB Width Expansion Threshold
input double InpBBWidthCompressionThreshold = 0.008;  // BB Width Compression Threshold
input double InpATRPercentileHigh = 70.0;             // ATR Percentile High
input double InpATRPercentileLow = 30.0;              // ATR Percentile Low

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - ENTRY FILTERS                                 |
//+------------------------------------------------------------------+
input group "========== ENTRY FILTERS =========="
input double InpMaxSpreadPoints = 30.0;               // Max Spread For Entry (points)
input double InpMaxSlippagePoints = 20.0;             // Max Slippage For Entry (points)
input double InpMinStructuralRoomR = 1.5;             // Min Structural Room (R)
input double InpRSIOverboughtLevel = 70.0;            // RSI Overbought Level
input double InpRSIOversoldLevel = 30.0;              // RSI Oversold Level

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - STOP & TARGET SETTINGS                        |
//+------------------------------------------------------------------+
input group "========== STOP & TARGET SETTINGS =========="
input double InpATRStopMultiplier = 1.5;              // ATR Stop Loss Multiplier
input double InpMinStopPoints = 100.0;                // Min Stop Loss (points)
input double InpMaxStopPoints = 500.0;                // Max Stop Loss (points)
input double InpTP1_RMultiple = 1.0;                  // TP1 R-Multiple
input double InpTP2_RMultiple = 2.0;                  // TP2 R-Multiple
input double InpTP3_RMultiple = 3.0;                  // TP3 R-Multiple

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - POSITION MANAGEMENT                           |
//+------------------------------------------------------------------+
input group "========== POSITION MANAGEMENT =========="
input double InpBreakEvenTriggerR = 1.0;              // Break Even Trigger (R)
input double InpBreakEvenBufferPoints = 5.0;          // Break Even Buffer (points)
input int InpMinBarsBeforeBE = 3;                     // Min Bars Before BE
input double InpPartial1Percent = 30.0;               // Partial 1 Close Percent
input double InpPartial2Percent = 30.0;               // Partial 2 Close Percent
input double InpPartial3Percent = 40.0;               // Partial 3 Close Percent (remainder)

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - TRAILING SETTINGS                             |
//+------------------------------------------------------------------+
input group "========== TRAILING SETTINGS =========="
input double InpATRTrailMultiplier = 2.0;             // ATR Trail Multiplier
input int InpSwingLookbackBars = 10;                  // Swing Lookback Bars
input double InpFastBankTriggerR = 0.5;               // Fast Bank Trigger (R)
input double InpFastBankProtectR = 0.3;               // Fast Bank Protect (R)

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - MDAE SETTINGS                                 |
//+------------------------------------------------------------------+
input group "========== MDAE SETTINGS =========="
input int InpMDAE_SpeedWindow = 10;                   // MDAE Speed Window (bars)
input int InpMDAE_VolumeWindow = 20;                  // MDAE Volume Window (bars)
input int InpMDAE_Top2Lookback = 20;                  // MDAE Top2 Lookback (bars)
input int InpMDAE_LVBoxLookback = 15;                 // MDAE Low Volume Box Lookback
input double InpMDAE_LVBoxVolumeThreshold = 0.7;      // MDAE LV Box Volume Threshold
input int InpMaxPolicySwitches = 2;                   // Max Policy Switches Per Trade

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - EXIT CONDITIONS                               |
//+------------------------------------------------------------------+
input group "========== EXIT CONDITIONS =========="
input int InpMaxTradeAgeBars = 200;                   // Max Trade Age (bars)
input double InpInvalidationRSIThreshold = 50.0;      // Invalidation RSI Threshold
input double InpEntropyThreshold = 0.6;               // Entropy Threshold For Protection

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - RISK GOVERNANCE                               |
//+------------------------------------------------------------------+
input group "========== RISK GOVERNANCE =========="
input double InpMaxDailyLossPercent = 2.0;            // Max Daily Loss (%)
input double InpMaxWeeklyLossPercent = 5.0;           // Max Weekly Loss (%)
input int InpMaxConsecutiveLosses = 3;                // Max Consecutive Losses

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - SESSION FILTER                                |
//+------------------------------------------------------------------+
input group "========== SESSION FILTER =========="
input int InpSessionStartHour = 7;                    // Session Start Hour (server time)
input int InpSessionEndHour = 20;                     // Session End Hour (server time)

//+------------------------------------------------------------------+
//| GLOBAL VARIABLES - INDICATOR HANDLES                             |
//+------------------------------------------------------------------+
int g_handleATR = INVALID_HANDLE;
int g_handleADX = INVALID_HANDLE;
int g_handleRSI = INVALID_HANDLE;
int g_handleEMAFast = INVALID_HANDLE;
int g_handleEMASlow = INVALID_HANDLE;
int g_handleBB = INVALID_HANDLE;

//+------------------------------------------------------------------+
//| GLOBAL VARIABLES - TRADE MANAGEMENT                              |
//+------------------------------------------------------------------+
CTrade g_trade;
datetime g_lastBarTime = 0;
datetime g_dayStamp = 0;
double g_startEquity = 0.0;
double g_startDayEquity = 0.0;
double g_startWeekEquity = 0.0;
int g_dailyTradeCount = 0;
int g_consecutiveLosses = 0;
bool g_dailyLockActive = false;
bool g_weeklyLockActive = false;

//+------------------------------------------------------------------+
//| GLOBAL VARIABLES - MANAGED POSITION STATE                        |
//+------------------------------------------------------------------+
struct ManagedPositionState
{
   ulong ticket;
   double entryPrice;
   double initialStopLoss;
   double initialRiskDistance;
   double initialVolume;
   datetime entryTime;
   int entryBar;
   
   bool beActivated;
   bool partial1Done;
   bool partial2Done;
   bool partial3Done;
   
   ENUM_CLOSE_METHOD activeMethod;
   int policySwitchCount;
   
   double maxFavorableExcursion;
   double maxAdverseExcursion;
   int ageInBars;
   
   double lastTrailPrice;
};

ManagedPositionState g_posState;

//+------------------------------------------------------------------+
//| GLOBAL VARIABLES - COMPLIANCE COUNTERS                           |
//+------------------------------------------------------------------+
int g_complianceViolationCount_Spread = 0;
int g_complianceViolationCount_Slippage = 0;

//+------------------------------------------------------------------+
//| GLOBAL VARIABLES - LOGGING                                       |
//+------------------------------------------------------------------+
int g_logFileHandle = INVALID_HANDLE;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // Initialize trade object
   g_trade.SetExpertMagicNumber(InpMagicNumber);
   g_trade.SetDeviationInPoints(50);
   g_trade.SetTypeFilling(ORDER_FILLING_FOK);
   g_trade.SetAsyncMode(false);
   
   // Validate symbol
   if(_Symbol != InpSymbol)
   {
      Print("ERROR: EA attached to ", _Symbol, " but configured for ", InpSymbol);
      return INIT_PARAMETERS_INCORRECT;
   }
   
   // Initialize indicator handles
   g_handleATR = iATR(InpSymbol, PERIOD_M1, InpATRPeriod);
   g_handleADX = iADX(InpSymbol, PERIOD_M1, InpADXPeriod);
   g_handleRSI = iRSI(InpSymbol, PERIOD_M1, InpRSIPeriod, PRICE_CLOSE);
   g_handleEMAFast = iMA(InpSymbol, PERIOD_M1, InpEMAFastPeriod, 0, MODE_EMA, PRICE_CLOSE);
   g_handleEMASlow = iMA(InpSymbol, PERIOD_M1, InpEMASlowPeriod, 0, MODE_EMA, PRICE_CLOSE);
   g_handleBB = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, 0, InpBBDeviation, PRICE_CLOSE);
   
   // Validate handles
   if(g_handleATR == INVALID_HANDLE || g_handleADX == INVALID_HANDLE || 
      g_handleRSI == INVALID_HANDLE || g_handleEMAFast == INVALID_HANDLE ||
      g_handleEMASlow == INVALID_HANDLE || g_handleBB == INVALID_HANDLE)
   {
      Print("ERROR: Failed to initialize indicator handles");
      return INIT_FAILED;
   }
   
   // Initialize equity trackers
   g_startEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   g_startDayEquity = g_startEquity;
   g_startWeekEquity = g_startEquity;
   
   // Initialize position state
   ResetManagedPositionState();
   
   // Check for existing position on restart
   if(PositionSelect(InpSymbol))
   {
      if(PositionGetInteger(POSITION_MAGIC) == InpMagicNumber)
      {
         ReconstructPositionState();
      }
   }
   
   // Initialize logging
   if(InpEnableLogging)
   {
      InitializeLogging();
   }
   
   Print("XAUUSD Adaptive MDAE EA initialized successfully");
   Print("Compliance Enforcement: Spread=", InpEnforceNoSpreadSlStopMoves, 
         " Slippage=", InpEnforceNoSlippageStopMoves);
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // Release indicator handles
   if(g_handleATR != INVALID_HANDLE) IndicatorRelease(g_handleATR);
   if(g_handleADX != INVALID_HANDLE) IndicatorRelease(g_handleADX);
   if(g_handleRSI != INVALID_HANDLE) IndicatorRelease(g_handleRSI);
   if(g_handleEMAFast != INVALID_HANDLE) IndicatorRelease(g_handleEMAFast);
   if(g_handleEMASlow != INVALID_HANDLE) IndicatorRelease(g_handleEMASlow);
   if(g_handleBB != INVALID_HANDLE) IndicatorRelease(g_handleBB);
   
   // Close log file
   if(g_logFileHandle != INVALID_HANDLE)
   {
      FileClose(g_logFileHandle);
   }
   
   Print("XAUUSD Adaptive MDAE EA deinitialized. Reason: ", reason);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Master EA toggle
   if(!InpEnableEA) return;
   
   // Update daily trackers
   UpdateDailyTrackers();
   
   // Priority 1: Manage existing position first
   if(PositionSelect(InpSymbol))
   {
      if(PositionGetInteger(POSITION_MAGIC) == InpMagicNumber && InpEnablePositionManagement)
      {
         ManageOpenPosition();
      }
   }
   else
   {
      // No position - reset managed state if needed
      if(g_posState.ticket > 0)
      {
         ResetManagedPositionState();
      }
   }
   
   // Priority 2: Evaluate new entry on new bar
   if(IsNewBar() && InpEnableEntries)
   {
      EvaluateEntry();
   }
}

//+------------------------------------------------------------------+
//| Trade transaction event handler                                  |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
   // Track deal events for our symbol and magic
   if(trans.symbol == InpSymbol && trans.type == TRADE_TRANSACTION_DEAL_ADD)
   {
      ulong dealTicket = trans.deal;
      if(dealTicket > 0)
      {
         if(HistoryDealSelect(dealTicket))
         {
            if(HistoryDealGetInteger(dealTicket, DEAL_MAGIC) == InpMagicNumber)
            {
               ENUM_DEAL_ENTRY dealEntry = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(dealTicket, DEAL_ENTRY);
               double dealProfit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
               
               // Track consecutive losses
               if(dealEntry == DEAL_ENTRY_OUT)
               {
                  if(dealProfit < 0)
                  {
                     g_consecutiveLosses++;
                     LogEvent("DEAL_CLOSED", "Loss detected. Consecutive losses: " + IntegerToString(g_consecutiveLosses));
                  }
                  else
                  {
                     g_consecutiveLosses = 0;
                     LogEvent("DEAL_CLOSED", "Win detected. Consecutive losses reset.");
                  }
               }
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Check if new bar has formed                                      |
//+------------------------------------------------------------------+
bool IsNewBar()
{
   datetime currentBarTime = iTime(InpSymbol, PERIOD_M1, 0);
   if(currentBarTime != g_lastBarTime)
   {
      g_lastBarTime = currentBarTime;
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Update daily tracking variables                                  |
//+------------------------------------------------------------------+
void UpdateDailyTrackers()
{
   MqlDateTime dt;
   TimeCurrent(dt);
   
   datetime todayStamp = StringToTime(IntegerToString(dt.year) + "." + 
                                      IntegerToString(dt.mon) + "." + 
                                      IntegerToString(dt.day));
   
   if(todayStamp != g_dayStamp)
   {
      // New day - reset counters
      g_dayStamp = todayStamp;
      g_startDayEquity = AccountInfoDouble(ACCOUNT_EQUITY);
      g_dailyTradeCount = 0;
      g_dailyLockActive = false;
      
      LogEvent("NEW_DAY", "Daily trackers reset");
   }
}

//+------------------------------------------------------------------+
//| Check if trading is locked due to risk conditions                |
//+------------------------------------------------------------------+
bool IsTradingLocked()
{
   if(!InpEnableRiskGovernor) return false;
   
   double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   
   // Daily drawdown lock
   if(InpEnableDailyDDLock)
   {
      double dailyLoss = g_startDayEquity - currentEquity;
      double dailyLossPercent = (dailyLoss / g_startDayEquity) * 100.0;
      
      if(dailyLossPercent >= InpMaxDailyLossPercent)
      {
         if(!g_dailyLockActive)
         {
            g_dailyLockActive = true;
            LogEvent("RISK_LOCK", "Daily DD lock activated: " + DoubleToString(dailyLossPercent, 2) + "%");
         }
         return true;
      }
   }
   
   // Weekly drawdown lock
   if(InpEnableWeeklyDDLock)
   {
      double weeklyLoss = g_startWeekEquity - currentEquity;
      double weeklyLossPercent = (weeklyLoss / g_startWeekEquity) * 100.0;
      
      if(weeklyLossPercent >= InpMaxWeeklyLossPercent)
      {
         if(!g_weeklyLockActive)
         {
            g_weeklyLockActive = true;
            LogEvent("RISK_LOCK", "Weekly DD lock activated: " + DoubleToString(weeklyLossPercent, 2) + "%");
         }
         return true;
      }
   }
   
   // Consecutive loss lock
   if(InpEnableConsecutiveLossLock)
   {
      if(g_consecutiveLosses >= InpMaxConsecutiveLosses)
      {
         LogEvent("RISK_LOCK", "Consecutive loss lock active: " + IntegerToString(g_consecutiveLosses));
         return true;
      }
   }
   
   // Max trades per day
   if(InpEnableMaxTradesPerSession)
   {
      if(g_dailyTradeCount >= InpMaxTradesPerDay)
      {
         LogEvent("RISK_LOCK", "Max trades per day reached: " + IntegerToString(g_dailyTradeCount));
         return true;
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Detect current market regime                                     |
//+------------------------------------------------------------------+
ENUM_REGIME DetectRegime()
{
   if(!InpEnableRegimeEngine) return REGIME_NO_TRADE;
   
   double adx[], bbUpper[], bbLower[], bbMiddle[], atr[];
   ArraySetAsSeries(adx, true);
   ArraySetAsSeries(bbUpper, true);
   ArraySetAsSeries(bbLower, true);
   ArraySetAsSeries(bbMiddle, true);
   ArraySetAsSeries(atr, true);
   
   // Copy indicator buffers
   if(CopyBuffer(g_handleADX, 0, 0, 3, adx) <= 0) return REGIME_NO_TRADE;
   if(CopyBuffer(g_handleBB, 1, 0, 2, bbUpper) <= 0) return REGIME_NO_TRADE;
   if(CopyBuffer(g_handleBB, 2, 0, 2, bbLower) <= 0) return REGIME_NO_TRADE;
   if(CopyBuffer(g_handleBB, 0, 0, 2, bbMiddle) <= 0) return REGIME_NO_TRADE;
   if(CopyBuffer(g_handleATR, 0, 0, 2, atr) <= 0) return REGIME_NO_TRADE;
   
   // Calculate BB width
   double bbWidth = (bbUpper[0] - bbLower[0]) / bbMiddle[0];
   double bbWidthPrev = (bbUpper[1] - bbLower[1]) / bbMiddle[1];
   bool bbExpanding = bbWidth > bbWidthPrev;
   
   // ADX analysis
   double adxCurrent = adx[0];
   double adxSlope = adx[0] - adx[1];
   
   // Regime decision logic
   if(adxCurrent > InpADXTrendThreshold && adxSlope > 0 && 
      bbWidth > InpBBWidthExpansionThreshold && bbExpanding)
   {
      LogEvent("REGIME", "TREND_EXPANSION detected. ADX=" + DoubleToString(adxCurrent, 1) + 
               " BBW=" + DoubleToString(bbWidth, 5));
      return REGIME_TREND_EXPANSION;
   }
   
   if(adxCurrent < InpADXRangeThreshold && 
      bbWidth < InpBBWidthCompressionThreshold)
   {
      LogEvent("REGIME", "MEAN_REVERSION detected. ADX=" + DoubleToString(adxCurrent, 1) + 
               " BBW=" + DoubleToString(bbWidth, 5));
      return REGIME_MEAN_REVERSION;
   }
   
   LogEvent("REGIME", "NO_TRADE - unclear regime");
   return REGIME_NO_TRADE;
}

//+------------------------------------------------------------------+
//| Evaluate trend entry signal                                      |
//+------------------------------------------------------------------+
int EvaluateTrendEntry()
{
   if(!InpEnableTrendModule) return 0;
   
   double emaFast[], emaSlow[], rsi[], close[];
   ArraySetAsSeries(emaFast, true);
   ArraySetAsSeries(emaSlow, true);
   ArraySetAsSeries(rsi, true);
   ArraySetAsSeries(close, true);
   
   if(CopyBuffer(g_handleEMAFast, 0, 0, 3, emaFast) <= 0) return 0;
   if(CopyBuffer(g_handleEMASlow, 0, 0, 3, emaSlow) <= 0) return 0;
   if(CopyBuffer(g_handleRSI, 0, 0, 2, rsi) <= 0) return 0;
   if(CopyClose(InpSymbol, PERIOD_M1, 0, 3, close) <= 0) return 0;
   
   // Long setup: EMA fast > EMA slow, pullback recovery, RSI not overbought
   if(emaFast[0] > emaSlow[0] && emaFast[1] > emaSlow[1])
   {
      if(close[1] < emaFast[1] && close[0] > emaFast[0]) // Pullback recovery
      {
         if(rsi[0] < InpRSIOverboughtLevel && rsi[0] > 50.0)
         {
            LogEvent("SIGNAL", "LONG trend signal detected");
            return 1;
         }
      }
   }
   
   // Short setup: EMA fast < EMA slow, pullback recovery, RSI not oversold
   if(emaFast[0] < emaSlow[0] && emaFast[1] < emaSlow[1])
   {
      if(close[1] > emaFast[1] && close[0] < emaFast[0]) // Pullback recovery
      {
         if(rsi[0] > InpRSIOversoldLevel && rsi[0] < 50.0)
         {
            LogEvent("SIGNAL", "SHORT trend signal detected");
            return -1;
         }
      }
   }
   
   return 0;
}

//+------------------------------------------------------------------+
//| Evaluate mean reversion entry signal                             |
//+------------------------------------------------------------------+
int EvaluateMeanReversionEntry()
{
   if(!InpEnableMeanReversionModule) return 0;
   
   double bbUpper[], bbLower[], bbMiddle[], rsi[], close[];
   ArraySetAsSeries(bbUpper, true);
   ArraySetAsSeries(bbLower, true);
   ArraySetAsSeries(bbMiddle, true);
   ArraySetAsSeries(rsi, true);
   ArraySetAsSeries(close, true);
   
   if(CopyBuffer(g_handleBB, 1, 0, 2, bbUpper) <= 0) return 0;
   if(CopyBuffer(g_handleBB, 2, 0, 2, bbLower) <= 0) return 0;
   if(CopyBuffer(g_handleBB, 0, 0, 2, bbMiddle) <= 0) return 0;
   if(CopyBuffer(g_handleRSI, 0, 0, 2, rsi) <= 0) return 0;
   if(CopyClose(InpSymbol, PERIOD_M1, 0, 3, close) <= 0) return 0;
   
   // Long setup: touch/breach lower band then rejection, RSI oversold
   if(close[1] <= bbLower[1] && close[0] > bbLower[0])
   {
      if(rsi[0] < InpRSIOversoldLevel)
      {
         LogEvent("SIGNAL", "LONG mean reversion signal detected");
         return 1;
      }
   }
   
   // Short setup: touch/breach upper band then rejection, RSI overbought
   if(close[1] >= bbUpper[1] && close[0] < bbUpper[0])
   {
      if(rsi[0] > InpRSIOverboughtLevel)
      {
         LogEvent("SIGNAL", "SHORT mean reversion signal detected");
         return -1;
      }
   }
   
   return 0;
}

//+------------------------------------------------------------------+
//| Check session filter                                             |
//+------------------------------------------------------------------+
bool IsWithinTradingSession()
{
   if(!InpEnableSessionFilter) return true;
   
   MqlDateTime dt;
   TimeCurrent(dt);
   
   if(dt.hour >= InpSessionStartHour && dt.hour < InpSessionEndHour)
   {
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Check spread filter                                              |
//+------------------------------------------------------------------+
bool IsSpreadAcceptable()
{
   if(!InpEnableSpreadEntryFilter) return true;
   
   double spreadPoints = (SymbolInfoDouble(InpSymbol, SYMBOL_ASK) - 
                          SymbolInfoDouble(InpSymbol, SYMBOL_BID)) / 
                          SymbolInfoDouble(InpSymbol, SYMBOL_POINT);
   
   if(spreadPoints > InpMaxSpreadPoints)
   {
      LogEvent("FILTER", "Spread too high: " + DoubleToString(spreadPoints, 1) + " points");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Evaluate entry conditions                                        |
//+------------------------------------------------------------------+
void EvaluateEntry()
{
   // Check if position already exists
   if(InpEnableOnePositionOnly && PositionSelect(InpSymbol))
   {
      if(PositionGetInteger(POSITION_MAGIC) == InpMagicNumber)
      {
         return; // Already have a position
      }
   }
   
   // Check trading locks
   if(IsTradingLocked())
   {
      return;
   }
   
   // Check session filter
   if(!IsWithinTradingSession())
   {
      return;
   }
   
   // Check spread filter
   if(!IsSpreadAcceptable())
   {
      return;
   }
   
   // Detect regime
   ENUM_REGIME regime = DetectRegime();
   if(regime == REGIME_NO_TRADE)
   {
      return;
   }
   
   // Evaluate setup signals
   int signal = 0;
   
   if(regime == REGIME_TREND_EXPANSION)
   {
      signal = EvaluateTrendEntry();
   }
   else if(regime == REGIME_MEAN_REVERSION)
   {
      signal = EvaluateMeanReversionEntry();
   }
   
   // Execute entry if signal valid
   if(signal != 0)
   {
      ExecuteEntry(signal, regime);
   }
}

//+------------------------------------------------------------------+
//| Execute entry order                                              |
//+------------------------------------------------------------------+
void ExecuteEntry(int direction, ENUM_REGIME regime)
{
   // Get ATR for stop calculation
   double atr[];
   ArraySetAsSeries(atr, true);
   if(CopyBuffer(g_handleATR, 0, 0, 1, atr) <= 0)
   {
      LogEvent("ERROR", "Failed to get ATR for entry");
      return;
   }
   
   double atrValue = atr[0];
   double point = SymbolInfoDouble(InpSymbol, SYMBOL_POINT);
   
   // Calculate stop loss distance
   double slDistance = atrValue * InpATRStopMultiplier;
   double slDistancePoints = slDistance / point;
   
   // Apply min/max constraints
   if(slDistancePoints < InpMinStopPoints) slDistancePoints = InpMinStopPoints;
   if(slDistancePoints > InpMaxStopPoints) slDistancePoints = InpMaxStopPoints;
   
   slDistance = slDistancePoints * point;
   
   // Calculate position size
   double riskMoney = AccountInfoDouble(ACCOUNT_EQUITY) * (InpRiskPercent / 100.0);
   double tickValue = SymbolInfoDouble(InpSymbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(InpSymbol, SYMBOL_TRADE_TICK_SIZE);
   double lotSize = (riskMoney / slDistance) * (tickSize / tickValue);
   
   // Normalize lot size
   double minLot = SymbolInfoDouble(InpSymbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(InpSymbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(InpSymbol, SYMBOL_VOLUME_STEP);
   
   lotSize = MathFloor(lotSize / lotStep) * lotStep;
   if(lotSize < minLot) lotSize = minLot;
   if(lotSize > maxLot) lotSize = maxLot;
   
   // Get current price
   double price = (direction > 0) ? SymbolInfoDouble(InpSymbol, SYMBOL_ASK) : 
                                     SymbolInfoDouble(InpSymbol, SYMBOL_BID);
   
   // Calculate SL and TP
   double sl = (direction > 0) ? (price - slDistance) : (price + slDistance);
   double tp = 0; // Managed dynamically
   
   // Normalize prices
   int digits = (int)SymbolInfoInteger(InpSymbol, SYMBOL_DIGITS);
   sl = NormalizeDouble(sl, digits);
   price = NormalizeDouble(price, digits);
   
   // Place order
   bool result = false;
   if(direction > 0)
   {
      result = g_trade.Buy(lotSize, InpSymbol, price, sl, tp, "MDAE Long");
   }
   else
   {
      result = g_trade.Sell(lotSize, InpSymbol, price, sl, tp, "MDAE Short");
   }
   
   // Handle result
   if(result)
   {
      ulong ticket = g_trade.ResultOrder();
      g_dailyTradeCount++;
      
      // Initialize managed position state
      InitializeManagedPositionState(ticket, price, sl, slDistance, lotSize, direction);
      
      LogEvent("ENTRY", "Order opened. Ticket=" + IntegerToString(ticket) + 
               " Direction=" + IntegerToString(direction) + 
               " Lot=" + DoubleToString(lotSize, 2) +
               " SL Distance=" + DoubleToString(slDistancePoints, 1) + " points");
   }
   else
   {
      LogEvent("ERROR", "Order failed. Code=" + IntegerToString(g_trade.ResultRetcode()) +
               " Desc=" + g_trade.ResultRetcodeDescription());
   }
}

//+------------------------------------------------------------------+
//| Initialize managed position state                                |
//+------------------------------------------------------------------+
void InitializeManagedPositionState(ulong ticket, double entry, double sl, double slDist, double vol, int dir)
{
   g_posState.ticket = ticket;
   g_posState.entryPrice = entry;
   g_posState.initialStopLoss = sl;
   g_posState.initialRiskDistance = slDist;
   g_posState.initialVolume = vol;
   g_posState.entryTime = TimeCurrent();
   g_posState.entryBar = 0;
   
   g_posState.beActivated = false;
   g_posState.partial1Done = false;
   g_posState.partial2Done = false;
   g_posState.partial3Done = false;
   
   g_posState.activeMethod = CM_FIXED;
   g_posState.policySwitchCount = 0;
   
   g_posState.maxFavorableExcursion = 0.0;
   g_posState.maxAdverseExcursion = 0.0;
   g_posState.ageInBars = 0;
   
   g_posState.lastTrailPrice = 0.0;
}

//+------------------------------------------------------------------+
//| Reset managed position state                                     |
//+------------------------------------------------------------------+
void ResetManagedPositionState()
{
   g_posState.ticket = 0;
   g_posState.entryPrice = 0;
   g_posState.initialStopLoss = 0;
   g_posState.initialRiskDistance = 0;
   g_posState.initialVolume = 0;
   g_posState.entryTime = 0;
   g_posState.entryBar = 0;
   
   g_posState.beActivated = false;
   g_posState.partial1Done = false;
   g_posState.partial2Done = false;
   g_posState.partial3Done = false;
   
   g_posState.activeMethod = CM_FIXED;
   g_posState.policySwitchCount = 0;
   
   g_posState.maxFavorableExcursion = 0.0;
   g_posState.maxAdverseExcursion = 0.0;
   g_posState.ageInBars = 0;
   
   g_posState.lastTrailPrice = 0.0;
}

//+------------------------------------------------------------------+
//| Reconstruct position state on restart                            |
//+------------------------------------------------------------------+
void ReconstructPositionState()
{
   if(!PositionSelect(InpSymbol)) return;
   
   ulong ticket = PositionGetInteger(POSITION_TICKET);
   double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   double currentSL = PositionGetDouble(POSITION_SL);
   double volume = PositionGetDouble(POSITION_VOLUME);
   datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
   
   g_posState.ticket = ticket;
   g_posState.entryPrice = entryPrice;
   g_posState.initialStopLoss = currentSL;
   g_posState.initialRiskDistance = MathAbs(entryPrice - currentSL);
   g_posState.initialVolume = volume; // May be inaccurate if partials already done
   g_posState.entryTime = openTime;
   g_posState.entryBar = 0;
   
   // Infer BE status
   ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   if(posType == POSITION_TYPE_BUY)
   {
      g_posState.beActivated = (currentSL >= entryPrice);
   }
   else
   {
      g_posState.beActivated = (currentSL <= entryPrice);
   }
   
   // Cannot reliably infer partial states - assume not done
   g_posState.partial1Done = false;
   g_posState.partial2Done = false;
   g_posState.partial3Done = false;
   
   g_posState.activeMethod = CM_FIXED;
   g_posState.policySwitchCount = 0;
   
   g_posState.maxFavorableExcursion = 0.0;
   g_posState.maxAdverseExcursion = 0.0;
   g_posState.ageInBars = 0;
   
   LogEvent("RECONSTRUCT", "Position state reconstructed. Ticket=" + IntegerToString(ticket));
}

//+------------------------------------------------------------------+
//| Manage open position                                             |
//+------------------------------------------------------------------+
void ManageOpenPosition()
{
   if(!PositionSelect(InpSymbol)) return;
   
   // Update position metrics
   double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
   double entryPrice = g_posState.entryPrice;
   double currentSL = PositionGetDouble(POSITION_SL);
   double currentVolume = PositionGetDouble(POSITION_VOLUME);
   ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   int direction = (posType == POSITION_TYPE_BUY) ? 1 : -1;
   
   // Calculate R-multiple
   double riskDistance = g_posState.initialRiskDistance;
   double priceMove = (direction > 0) ? (currentPrice - entryPrice) : (entryPrice - currentPrice);
   double currentR = (riskDistance > 0) ? (priceMove / riskDistance) : 0.0;
   
   // Update MFE/MAE
   if(currentR > g_posState.maxFavorableExcursion)
   {
      g_posState.maxFavorableExcursion = currentR;
   }
   if(currentR < g_posState.maxAdverseExcursion)
   {
      g_posState.maxAdverseExcursion = currentR;
   }
   
   // Update age
   g_posState.ageInBars++;
   
   // Check invalidation exit
   if(InpEnableInvalidationExit && CheckInvalidationExit(direction, currentR))
   {
      ClosePosition("Invalidation exit");
      return;
   }
   
   // Check time stop
   if(InpEnableTimeStop && g_posState.ageInBars > InpMaxTradeAgeBars)
   {
      ClosePosition("Time stop - max age reached");
      return;
   }
   
   // Select close method (MDAE)
   if(InpEnableMDAE)
   {
      ENUM_CLOSE_METHOD newMethod = ChooseCloseMethod(direction, currentR);
      
      if(InpEnablePolicySwitching && newMethod != g_posState.activeMethod)
      {
         if(g_posState.policySwitchCount < InpMaxPolicySwitches)
         {
            g_posState.activeMethod = newMethod;
            g_posState.policySwitchCount++;
            LogEvent("MDAE", "Policy switched to method " + IntegerToString(newMethod) + 
                     " (switch #" + IntegerToString(g_posState.policySwitchCount) + ")");
         }
      }
   }
   
   // Execute partial closes
   if(InpEnablePartialClose)
   {
      ExecutePartialCloses(currentR, currentVolume);
   }
   
   // Execute break even
   if(InpEnableBreakEven)
   {
      ExecuteBreakEven(currentR, direction);
   }
   
   // Execute trailing
   ExecuteTrailing(direction, currentR, currentPrice, currentSL);
}

//+------------------------------------------------------------------+
//| Check invalidation exit conditions                               |
//+------------------------------------------------------------------+
bool CheckInvalidationExit(int direction, double currentR)
{
   // RSI invalidation
   double rsi[];
   ArraySetAsSeries(rsi, true);
   if(CopyBuffer(g_handleRSI, 0, 0, 1, rsi) > 0)
   {
      if(direction > 0 && rsi[0] < InpInvalidationRSIThreshold && currentR < 0.5)
      {
         LogEvent("INVALIDATION", "Long thesis invalidated - RSI below threshold");
         return true;
      }
      if(direction < 0 && rsi[0] > (100.0 - InpInvalidationRSIThreshold) && currentR < 0.5)
      {
         LogEvent("INVALIDATION", "Short thesis invalidated - RSI above threshold");
         return true;
      }
   }
   
   // Regime flip invalidation
   ENUM_REGIME currentRegime = DetectRegime();
   if(currentRegime == REGIME_NO_TRADE && currentR < 1.0)
   {
      LogEvent("INVALIDATION", "Regime turned NO_TRADE with low profit");
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Choose close method based on MDAE features                       |
//+------------------------------------------------------------------+
ENUM_CLOSE_METHOD ChooseCloseMethod(int direction, double currentR)
{
   // Calculate MDAE features
   double speedRatio = CalculateSpeedRatio();
   double volumePulse = CalculateVolumePulse();
   bool top2Breakout = CheckTop2Breakout(direction);
   bool inLowVolumeBox = CheckLowVolumeBox();
   double entropy = CalculateEntropy(speedRatio, volumePulse);
   
   // Decision logic
   if(InpEnableFastBankMode && currentR >= InpFastBankTriggerR && entropy > InpEntropyThreshold)
   {
      return CM_FAST_BANK;
   }
   
   if(InpEnableEntropyScoring && entropy > InpEntropyThreshold)
   {
      return CM_HYBRID;
   }
   
   if(InpEnablePipsPerSecond && speedRatio > 1.5 && InpEnableTop2BreakoutCheck && top2Breakout)
   {
      if(InpEnableSwingTrail)
         return CM_STRUCTURE_TRAIL;
   }
   
   if(InpEnableATRTrail && speedRatio > 1.0)
   {
      return CM_ATR_TRAIL;
   }
   
   if(InpEnableLowVolumeBox && inLowVolumeBox)
   {
      return CM_FIXED;
   }
   
   // Default to hybrid if enabled, otherwise fixed
   if(InpEnableHybridCloseMode)
      return CM_HYBRID;
   
   return CM_FIXED;
}

//+------------------------------------------------------------------+
//| Calculate speed ratio (pips per second analysis)                 |
//+------------------------------------------------------------------+
double CalculateSpeedRatio()
{
   if(!InpEnablePipsPerSecond) return 1.0;
   
   double close[];
   ArraySetAsSeries(close, true);
   if(CopyClose(InpSymbol, PERIOD_M1, 0, InpMDAE_SpeedWindow + 1, close) <= 0)
      return 1.0;
   
   double point = SymbolInfoDouble(InpSymbol, SYMBOL_POINT);
   double recentMove = MathAbs(close[0] - close[1]) / point;
   
   double avgMove = 0.0;
   for(int i = 1; i <= InpMDAE_SpeedWindow; i++)
   {
      avgMove += MathAbs(close[i] - close[i+1]) / point;
   }
   avgMove /= InpMDAE_SpeedWindow;
   
   return (avgMove > 0) ? (recentMove / avgMove) : 1.0;
}

//+------------------------------------------------------------------+
//| Calculate volume pulse                                           |
//+------------------------------------------------------------------+
double CalculateVolumePulse()
{
   if(!InpEnableVolumePulse) return 1.0;
   
   long volume[];
   ArraySetAsSeries(volume, true);
   if(CopyTickVolume(InpSymbol, PERIOD_M1, 0, InpMDAE_VolumeWindow + 1, volume) <= 0)
      return 1.0;
   
   long recentVol = volume[0];
   
   double avgVol = 0.0;
   for(int i = 1; i <= InpMDAE_VolumeWindow; i++)
   {
      avgVol += (double)volume[i];
   }
   avgVol /= InpMDAE_VolumeWindow;
   
   return (avgVol > 0) ? (recentVol / avgVol) : 1.0;
}

//+------------------------------------------------------------------+
//| Check top2 breakout                                              |
//+------------------------------------------------------------------+
bool CheckTop2Breakout(int direction)
{
   if(!InpEnableTop2BreakoutCheck) return false;
   
   double high[], low[];
   ArraySetAsSeries(high, true);
   ArraySetAsSeries(low, true);
   
   if(CopyHigh(InpSymbol, PERIOD_M1, 0, InpMDAE_Top2Lookback + 1, high) <= 0) return false;
   if(CopyLow(InpSymbol, PERIOD_M1, 0, InpMDAE_Top2Lookback + 1, low) <= 0) return false;
   
   // Find highest high and lowest low in lookback (excluding current bar)
   double maxHigh = high[1];
   double minLow = low[1];
   for(int i = 2; i <= InpMDAE_Top2Lookback; i++)
   {
      if(high[i] > maxHigh) maxHigh = high[i];
      if(low[i] < minLow) minLow = low[i];
   }
   
   if(direction > 0 && high[0] > maxHigh) return true;
   if(direction < 0 && low[0] < minLow) return true;
   
   return false;
}

//+------------------------------------------------------------------+
//| Check low volume box                                             |
//+------------------------------------------------------------------+
bool CheckLowVolumeBox()
{
   if(!InpEnableLowVolumeBox) return false;
   
   long volume[];
   ArraySetAsSeries(volume, true);
   if(CopyTickVolume(InpSymbol, PERIOD_M1, 0, InpMDAE_LVBoxLookback + 1, volume) <= 0)
      return false;
   
   // Calculate average volume
   double avgVol = 0.0;
   for(int i = 0; i < InpMDAE_LVBoxLookback; i++)
   {
      avgVol += (double)volume[i];
   }
   avgVol /= InpMDAE_LVBoxLookback;
   
   // Check if recent volume is consistently low
   int lowVolCount = 0;
   for(int i = 0; i < 5; i++)
   {
      if((double)volume[i] < avgVol * InpMDAE_LVBoxVolumeThreshold)
         lowVolCount++;
   }
   
   return (lowVolCount >= 3);
}

//+------------------------------------------------------------------+
//| Calculate entropy (uncertainty) score                            |
//+------------------------------------------------------------------+
double CalculateEntropy(double speedRatio, double volumePulse)
{
   if(!InpEnableEntropyScoring) return 0.0;
   
   // Simple entropy heuristic: conflicting signals = high entropy
   double entropy = 0.0;
   
   if(speedRatio < 0.8 && volumePulse > 1.2) entropy += 0.3;
   if(speedRatio > 1.2 && volumePulse < 0.8) entropy += 0.3;
   
   double rsi[];
   ArraySetAsSeries(rsi, true);
   if(CopyBuffer(g_handleRSI, 0, 0, 2, rsi) > 0)
   {
      double rsiChange = MathAbs(rsi[0] - rsi[1]);
      if(rsiChange > 10.0) entropy += 0.2;
   }
   
   if(CheckLowVolumeBox()) entropy += 0.2;
   
   return MathMin(entropy, 1.0);
}

//+------------------------------------------------------------------+
//| Execute partial closes at milestones                             |
//+------------------------------------------------------------------+
void ExecutePartialCloses(double currentR, double currentVolume)
{
   double minLot = SymbolInfoDouble(InpSymbol, SYMBOL_VOLUME_MIN);
   double lotStep = SymbolInfoDouble(InpSymbol, SYMBOL_VOLUME_STEP);
   
   // Partial 1 at TP1_RMultiple
   if(!g_posState.partial1Done && currentR >= InpTP1_RMultiple)
   {
      double closePercent = InpPartial1Percent / 100.0;
      double closeVolume = currentVolume * closePercent;
      closeVolume = MathFloor(closeVolume / lotStep) * lotStep;
      
      if(closeVolume >= minLot && closeVolume < currentVolume)
      {
         if(ClosePartial(closeVolume))
         {
            g_posState.partial1Done = true;
            LogEvent("PARTIAL", "Partial 1 closed at " + DoubleToString(currentR, 2) + "R. Volume=" + 
                     DoubleToString(closeVolume, 2));
         }
      }
   }
   
   // Partial 2 at TP2_RMultiple
   if(!g_posState.partial2Done && g_posState.partial1Done && currentR >= InpTP2_RMultiple)
   {
      currentVolume = PositionGetDouble(POSITION_VOLUME);
      double closePercent = InpPartial2Percent / 100.0;
      double closeVolume = currentVolume * closePercent;
      closeVolume = MathFloor(closeVolume / lotStep) * lotStep;
      
      if(closeVolume >= minLot && closeVolume < currentVolume)
      {
         if(ClosePartial(closeVolume))
         {
            g_posState.partial2Done = true;
            LogEvent("PARTIAL", "Partial 2 closed at " + DoubleToString(currentR, 2) + "R. Volume=" + 
                     DoubleToString(closeVolume, 2));
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Close partial position                                           |
//+------------------------------------------------------------------+
bool ClosePartial(double volume)
{
   if(!PositionSelect(InpSymbol)) return false;
   
   ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   double price = (posType == POSITION_TYPE_BUY) ? SymbolInfoDouble(InpSymbol, SYMBOL_BID) :
                                                     SymbolInfoDouble(InpSymbol, SYMBOL_ASK);
   
   bool result = g_trade.PositionClosePartial(InpSymbol, volume, 50);
   
   if(!result)
   {
      LogEvent("ERROR", "Partial close failed. Code=" + IntegerToString(g_trade.ResultRetcode()));
   }
   
   return result;
}

//+------------------------------------------------------------------+
//| Execute break even move                                          |
//+------------------------------------------------------------------+
void ExecuteBreakEven(double currentR, int direction)
{
   if(g_posState.beActivated) return;
   if(currentR < InpBreakEvenTriggerR) return;
   if(g_posState.ageInBars < InpMinBarsBeforeBE) return;
   
   double currentSL = PositionGetDouble(POSITION_SL);
   double entryPrice = g_posState.entryPrice;
   double point = SymbolInfoDouble(InpSymbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(InpSymbol, SYMBOL_DIGITS);
   
   double newSL = entryPrice + (direction * InpBreakEvenBufferPoints * point);
   newSL = NormalizeDouble(newSL, digits);
   
   // Validate move
   bool validMove = false;
   if(direction > 0 && newSL > currentSL) validMove = true;
   if(direction < 0 && newSL < currentSL) validMove = true;
   
   if(validMove)
   {
      if(ModifyPositionSL(newSL))
      {
         g_posState.beActivated = true;
         LogEvent("BREAKEVEN", "Break even activated at " + DoubleToString(currentR, 2) + "R");
      }
   }
}

//+------------------------------------------------------------------+
//| Execute trailing logic based on active method                    |
//+------------------------------------------------------------------+
void ExecuteTrailing(int direction, double currentR, double currentPrice, double currentSL)
{
   if(currentR < 1.0) return; // Only trail after positive profit
   
   double newSL = currentSL;
   bool shouldUpdate = false;
   
   switch(g_posState.activeMethod)
   {
      case CM_ATR_TRAIL:
         if(InpEnableATRTrail)
         {
            double atr[];
            ArraySetAsSeries(atr, true);
            if(CopyBuffer(g_handleATR, 0, 0, 1, atr) > 0)
            {
               double trailDistance = atr[0] * InpATRTrailMultiplier;
               double candidateSL = (direction > 0) ? (currentPrice - trailDistance) : 
                                                       (currentPrice + trailDistance);
               
               if(direction > 0 && candidateSL > currentSL)
               {
                  newSL = candidateSL;
                  shouldUpdate = true;
               }
               if(direction < 0 && candidateSL < currentSL)
               {
                  newSL = candidateSL;
                  shouldUpdate = true;
               }
            }
         }
         break;
         
      case CM_STRUCTURE_TRAIL:
         if(InpEnableSwingTrail)
         {
            double swingSL = CalculateSwingTrailSL(direction);
            if(swingSL > 0)
            {
               if(direction > 0 && swingSL > currentSL)
               {
                  newSL = swingSL;
                  shouldUpdate = true;
               }
               if(direction < 0 && swingSL < currentSL)
               {
                  newSL = swingSL;
                  shouldUpdate = true;
               }
            }
         }
         break;
         
      case CM_FAST_BANK:
         if(InpEnableFastBankMode && currentR > InpFastBankProtectR)
         {
            double protectDistance = g_posState.initialRiskDistance * InpFastBankProtectR;
            double protectSL = (direction > 0) ? (currentPrice - protectDistance) : 
                                                  (currentPrice + protectDistance);
            
            if(direction > 0 && protectSL > currentSL)
            {
               newSL = protectSL;
               shouldUpdate = true;
            }
            if(direction < 0 && protectSL < currentSL)
            {
               newSL = protectSL;
               shouldUpdate = true;
            }
         }
         break;
         
      case CM_HYBRID:
         // Use ATR trail as default hybrid behavior
         if(InpEnableATRTrail)
         {
            double atr[];
            ArraySetAsSeries(atr, true);
            if(CopyBuffer(g_handleATR, 0, 0, 1, atr) > 0)
            {
               double trailDistance = atr[0] * InpATRTrailMultiplier;
               double candidateSL = (direction > 0) ? (currentPrice - trailDistance) : 
                                                       (currentPrice + trailDistance);
               
               if(direction > 0 && candidateSL > currentSL)
               {
                  newSL = candidateSL;
                  shouldUpdate = true;
               }
               if(direction < 0 && candidateSL < currentSL)
               {
                  newSL = candidateSL;
                  shouldUpdate = true;
               }
            }
         }
         break;
   }
   
   // Execute SL modification if valid
   if(shouldUpdate)
   {
      int digits = (int)SymbolInfoInteger(InpSymbol, SYMBOL_DIGITS);
      newSL = NormalizeDouble(newSL, digits);
      
      if(ModifyPositionSL(newSL))
      {
         LogEvent("TRAIL", "SL trailed by method " + IntegerToString(g_posState.activeMethod) + 
                  " to " + DoubleToString(newSL, digits));
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate swing-based trailing stop                              |
//+------------------------------------------------------------------+
double CalculateSwingTrailSL(int direction)
{
   double high[], low[];
   ArraySetAsSeries(high, true);
   ArraySetAsSeries(low, true);
   
   if(CopyHigh(InpSymbol, PERIOD_M1, 0, InpSwingLookbackBars + 1, high) <= 0) return 0;
   if(CopyLow(InpSymbol, PERIOD_M1, 0, InpSwingLookbackBars + 1, low) <= 0) return 0;
   
   double swingLevel = 0;
   
   if(direction > 0)
   {
      // Find lowest low in lookback
      swingLevel = low[1];
      for(int i = 2; i <= InpSwingLookbackBars; i++)
      {
         if(low[i] < swingLevel) swingLevel = low[i];
      }
   }
   else
   {
      // Find highest high in lookback
      swingLevel = high[1];
      for(int i = 2; i <= InpSwingLookbackBars; i++)
      {
         if(high[i] > swingLevel) swingLevel = high[i];
      }
   }
   
   return swingLevel;
}

//+------------------------------------------------------------------+
//| Modify position stop loss                                        |
//+------------------------------------------------------------------+
bool ModifyPositionSL(double newSL)
{
   if(!PositionSelect(InpSymbol)) return false;
   
   // COMPLIANCE CHECK: Never modify SL due to spread/slippage
   if(InpEnableComplianceAuditCounters)
   {
      // This function is ONLY called by strategy logic, not spread/slippage
      // No compliance violation here
   }
   
   double currentTP = PositionGetDouble(POSITION_TP);
   bool result = g_trade.PositionModify(InpSymbol, newSL, currentTP);
   
   if(!result)
   {
      LogEvent("ERROR", "SL modify failed. Code=" + IntegerToString(g_trade.ResultRetcode()));
   }
   
   return result;
}

//+------------------------------------------------------------------+
//| Close position completely                                        |
//+------------------------------------------------------------------+
void ClosePosition(string reason)
{
   if(!PositionSelect(InpSymbol)) return;
   
   bool result = g_trade.PositionClose(InpSymbol, 50);
   
   if(result)
   {
      LogEvent("EXIT", "Position closed. Reason: " + reason + 
               " MFE=" + DoubleToString(g_posState.maxFavorableExcursion, 2) + "R" +
               " MAE=" + DoubleToString(g_posState.maxAdverseExcursion, 2) + "R");
      
      ResetManagedPositionState();
   }
   else
   {
      LogEvent("ERROR", "Close failed. Code=" + IntegerToString(g_trade.ResultRetcode()));
   }
}

//+------------------------------------------------------------------+
//| Initialize logging system                                        |
//+------------------------------------------------------------------+
void InitializeLogging()
{
   string filename = "XAUUSD_MDAE_" + IntegerToString(InpMagicNumber) + "_" + 
                     TimeToString(TimeCurrent(), TIME_DATE) + ".log";
   
   g_logFileHandle = FileOpen(filename, FILE_WRITE|FILE_TXT|FILE_ANSI|FILE_SHARE_READ);
   
   if(g_logFileHandle != INVALID_HANDLE)
   {
      FileWrite(g_logFileHandle, "=== XAUUSD Adaptive MDAE EA Log ===");
      FileWrite(g_logFileHandle, "Start Time: " + TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS));
      FileWrite(g_logFileHandle, "Magic Number: " + IntegerToString(InpMagicNumber));
      FileWrite(g_logFileHandle, "");
   }
}

//+------------------------------------------------------------------+
//| Log event to file and print                                      |
//+------------------------------------------------------------------+
void LogEvent(string eventType, string message)
{
   if(!InpEnableLogging) return;
   
   string timestamp = TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS);
   string logLine = timestamp + " [" + eventType + "] " + message;
   
   if(InpEnableDebugPrints)
   {
      Print(logLine);
   }
   
   if(g_logFileHandle != INVALID_HANDLE)
   {
      FileWrite(g_logFileHandle, logLine);
      FileFlush(g_logFileHandle);
   }
}
//+------------------------------------------------------------------+     mqll4 :  //+------------------------------------------------------------------+
//|                                    XAUUSD_Adaptive_MDAE_EA.mq4 |
//|                                       Production-Ready MT4 Code |
//|                     Full Implementation with All Toggles & Logic |
//|                           MT4-Compatible Position Management     |
//+------------------------------------------------------------------+
#property copyright "XAUUSD Adaptive MDAE System"
#property version   "1.00"
#property strict

//+------------------------------------------------------------------+
//| ENUMERATIONS                                                      |
//+------------------------------------------------------------------+
enum ENUM_REGIME
{
   REGIME_NO_TRADE = 0,
   REGIME_TREND_EXPANSION = 1,
   REGIME_MEAN_REVERSION = 2
};

enum ENUM_CLOSE_METHOD
{
   CM_FIXED = 1,
   CM_ATR_TRAIL = 2,
   CM_STRUCTURE_TRAIL = 3,
   CM_FAST_BANK = 4,
   CM_INVALIDATION_EXIT = 5,
   CM_HYBRID = 6
};

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - MASTER TOGGLES                                |
//+------------------------------------------------------------------+
input string sep1 = "========== MASTER TOGGLES =========="; // ----
input bool InpEnableEA = true;                        // Enable EA
input bool InpEnableEntries = true;                   // Enable New Entries
input bool InpEnablePositionManagement = true;        // Enable Position Management
input bool InpEnableLogging = true;                   // Enable Logging
input bool InpEnableDebugPrints = false;              // Enable Debug Prints

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - REGIME & ENTRY TOGGLES                        |
//+------------------------------------------------------------------+
input string sep2 = "========== REGIME & ENTRY TOGGLES =========="; // ----
input bool InpEnableRegimeEngine = true;              // Enable Regime Detection
input bool InpEnableTrendModule = true;               // Enable Trend Entry Module
input bool InpEnableMeanReversionModule = true;       // Enable Mean Reversion Module
input bool InpEnableNoTradeState = true;              // Enable NO_TRADE State
input bool InpEnableMTFContextCheck = true;           // Enable MTF Context Check
input bool InpEnableVWAPCheck = false;                // Enable VWAP Check (fallback)
input bool InpEnableSessionFilter = true;             // Enable Session Filter
input bool InpEnableNewsWindowBlock = false;          // Enable News Window Block

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - RISK & EXECUTION TOGGLES                      |
//+------------------------------------------------------------------+
input string sep3 = "========== RISK & EXECUTION TOGGLES =========="; // ----
input bool InpEnableRiskGovernor = true;              // Enable Risk Governor
input bool InpEnableDailyDDLock = true;               // Enable Daily DD Lock
input bool InpEnableWeeklyDDLock = false;             // Enable Weekly DD Lock
input bool InpEnableConsecutiveLossLock = true;       // Enable Consecutive Loss Lock
input bool InpEnableSpreadEntryFilter = true;         // Enable Spread Entry Filter
input bool InpEnableSlippageEntryFilter = false;      // Enable Slippage Entry Filter
input bool InpEnableOnePositionOnly = true;           // Enable One Position Only
input bool InpEnableMaxTradesPerSession = true;       // Enable Max Trades Per Session

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - MDAE FEATURE TOGGLES                          |
//+------------------------------------------------------------------+
input string sep4 = "========== MDAE FEATURE TOGGLES =========="; // ----
input bool InpEnableMDAE = true;                      // Enable MDAE System
input bool InpEnablePipsPerSecond = true;             // Enable Pips/Second Analysis
input bool InpEnableVolumePulse = true;               // Enable Volume Pulse Analysis
input bool InpEnableBodyExpansion = true;             // Enable Body Expansion Check
input bool InpEnableTop2BreakoutCheck = true;         // Enable Top2 Breakout Check
input bool InpEnableLowVolumeBox = true;              // Enable Low Volume Box
input bool InpEnableFibGuidance = false;              // Enable Fib Guidance
input bool InpEnableEntropyScoring = true;            // Enable Entropy Scoring
input bool InpEnablePolicySwitching = true;           // Enable Policy Switching

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - EXIT & ACTION TOGGLES                         |
//+------------------------------------------------------------------+
input string sep5 = "========== EXIT & ACTION TOGGLES =========="; // ----
input bool InpEnablePartialClose = true;              // Enable Partial Close
input bool InpEnableBreakEven = true;                 // Enable Break Even
input bool InpEnableATRTrail = true;                  // Enable ATR Trailing
input bool InpEnableSwingTrail = true;                // Enable Swing Trailing
input bool InpEnableFastBankMode = true;              // Enable Fast Bank Mode
input bool InpEnableHybridCloseMode = true;           // Enable Hybrid Close Mode
input bool InpEnableInvalidationExit = true;          // Enable Invalidation Exit
input bool InpEnableTimeStop = true;                  // Enable Time Stop

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - COMPLIANCE TOGGLES (CRITICAL)                 |
//+------------------------------------------------------------------+
input string sep6 = "========== COMPLIANCE TOGGLES (CRITICAL) =========="; // ----
input bool InpEnforceNoSpreadSlStopMoves = true;      // Enforce No Spread-Based SL Moves
input bool InpEnforceNoSlippageStopMoves = true;      // Enforce No Slippage-Based SL Moves
input bool InpEnableComplianceAuditCounters = true;   // Enable Compliance Audit Counters

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - CORE SETTINGS                                 |
//+------------------------------------------------------------------+
input string sep7 = "========== CORE SETTINGS =========="; // ----
input string InpSymbol = "XAUUSD";                    // Trading Symbol
input int InpMagicNumber = 220262;                    // Magic Number
input double InpRiskPercent = 0.5;                    // Risk Per Trade (%)
input int InpMaxTradesPerDay = 3;                     // Max Trades Per Day
input int InpSlippage = 50;                           // Max Slippage (points)

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - INDICATOR SETTINGS                            |
//+------------------------------------------------------------------+
input string sep8 = "========== INDICATOR SETTINGS =========="; // ----
input int InpATRPeriod = 14;                          // ATR Period
input int InpADXPeriod = 14;                          // ADX Period
input int InpRSIPeriod = 14;                          // RSI Period
input int InpEMAFastPeriod = 20;                      // EMA Fast Period
input int InpEMASlowPeriod = 50;                      // EMA Slow Period
input int InpBBPeriod = 20;                           // Bollinger Bands Period
input double InpBBDeviation = 2.0;                    // Bollinger Bands Deviation

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - REGIME THRESHOLDS                             |
//+------------------------------------------------------------------+
input string sep9 = "========== REGIME THRESHOLDS =========="; // ----
input double InpADXTrendThreshold = 25.0;             // ADX Trend Threshold
input double InpADXRangeThreshold = 20.0;             // ADX Range Threshold
input double InpBBWidthExpansionThreshold = 0.015;    // BB Width Expansion Threshold
input double InpBBWidthCompressionThreshold = 0.008;  // BB Width Compression Threshold
input double InpATRPercentileHigh = 70.0;             // ATR Percentile High
input double InpATRPercentileLow = 30.0;              // ATR Percentile Low

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - ENTRY FILTERS                                 |
//+------------------------------------------------------------------+
input string sep10 = "========== ENTRY FILTERS =========="; // ----
input double InpMaxSpreadPoints = 30.0;               // Max Spread For Entry (points)
input double InpMaxSlippagePoints = 20.0;             // Max Slippage For Entry (points)
input double InpMinStructuralRoomR = 1.5;             // Min Structural Room (R)
input double InpRSIOverboughtLevel = 70.0;            // RSI Overbought Level
input double InpRSIOversoldLevel = 30.0;              // RSI Oversold Level

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - STOP & TARGET SETTINGS                        |
//+------------------------------------------------------------------+
input string sep11 = "========== STOP & TARGET SETTINGS =========="; // ----
input double InpATRStopMultiplier = 1.5;              // ATR Stop Loss Multiplier
input double InpMinStopPoints = 100.0;                // Min Stop Loss (points)
input double InpMaxStopPoints = 500.0;                // Max Stop Loss (points)
input double InpTP1_RMultiple = 1.0;                  // TP1 R-Multiple
input double InpTP2_RMultiple = 2.0;                  // TP2 R-Multiple
input double InpTP3_RMultiple = 3.0;                  // TP3 R-Multiple

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - POSITION MANAGEMENT                           |
//+------------------------------------------------------------------+
input string sep12 = "========== POSITION MANAGEMENT =========="; // ----
input double InpBreakEvenTriggerR = 1.0;              // Break Even Trigger (R)
input double InpBreakEvenBufferPoints = 5.0;          // Break Even Buffer (points)
input int InpMinBarsBeforeBE = 3;                     // Min Bars Before BE
input double InpPartial1Percent = 30.0;               // Partial 1 Close Percent
input double InpPartial2Percent = 30.0;               // Partial 2 Close Percent
input double InpPartial3Percent = 40.0;               // Partial 3 Close Percent (remainder)

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - TRAILING SETTINGS                             |
//+------------------------------------------------------------------+
input string sep13 = "========== TRAILING SETTINGS =========="; // ----
input double InpATRTrailMultiplier = 2.0;             // ATR Trail Multiplier
input int InpSwingLookbackBars = 10;                  // Swing Lookback Bars
input double InpFastBankTriggerR = 0.5;               // Fast Bank Trigger (R)
input double InpFastBankProtectR = 0.3;               // Fast Bank Protect (R)

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - MDAE SETTINGS                                 |
//+------------------------------------------------------------------+
input string sep14 = "========== MDAE SETTINGS =========="; // ----
input int InpMDAE_SpeedWindow = 10;                   // MDAE Speed Window (bars)
input int InpMDAE_VolumeWindow = 20;                  // MDAE Volume Window (bars)
input int InpMDAE_Top2Lookback = 20;                  // MDAE Top2 Lookback (bars)
input int InpMDAE_LVBoxLookback = 15;                 // MDAE Low Volume Box Lookback
input double InpMDAE_LVBoxVolumeThreshold = 0.7;      // MDAE LV Box Volume Threshold
input int InpMaxPolicySwitches = 2;                   // Max Policy Switches Per Trade

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - EXIT CONDITIONS                               |
//+------------------------------------------------------------------+
input string sep15 = "========== EXIT CONDITIONS =========="; // ----
input int InpMaxTradeAgeBars = 200;                   // Max Trade Age (bars)
input double InpInvalidationRSIThreshold = 50.0;      // Invalidation RSI Threshold
input double InpEntropyThreshold = 0.6;               // Entropy Threshold For Protection

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - RISK GOVERNANCE                               |
//+------------------------------------------------------------------+
input string sep16 = "========== RISK GOVERNANCE =========="; // ----
input double InpMaxDailyLossPercent = 2.0;            // Max Daily Loss (%)
input double InpMaxWeeklyLossPercent = 5.0;           // Max Weekly Loss (%)
input int InpMaxConsecutiveLosses = 3;                // Max Consecutive Losses

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - SESSION FILTER                                |
//+------------------------------------------------------------------+
input string sep17 = "========== SESSION FILTER =========="; // ----
input int InpSessionStartHour = 7;                    // Session Start Hour (server time)
input int InpSessionEndHour = 20;                     // Session End Hour (server time)

//+------------------------------------------------------------------+
//| GLOBAL VARIABLES - TRADE MANAGEMENT                              |
//+------------------------------------------------------------------+
datetime g_lastBarTime = 0;
datetime g_dayStamp = 0;
double g_startEquity = 0.0;
double g_startDayEquity = 0.0;
double g_startWeekEquity = 0.0;
int g_dailyTradeCount = 0;
int g_consecutiveLosses = 0;
bool g_dailyLockActive = false;
bool g_weeklyLockActive = false;

//+------------------------------------------------------------------+
//| GLOBAL VARIABLES - MANAGED POSITION STATE                        |
//+------------------------------------------------------------------+
struct ManagedPositionState
{
   int ticket;
   double entryPrice;
   double initialStopLoss;
   double initialRiskDistance;
   double initialVolume;
   datetime entryTime;
   int entryBar;
   
   bool beActivated;
   bool partial1Done;
   bool partial2Done;
   bool partial3Done;
   
   int activeMethod;
   int policySwitchCount;
   
   double maxFavorableExcursion;
   double maxAdverseExcursion;
   int ageInBars;
   
   double lastTrailPrice;
};

ManagedPositionState g_posState;

//+------------------------------------------------------------------+
//| GLOBAL VARIABLES - COMPLIANCE COUNTERS                           |
//+------------------------------------------------------------------+
int g_complianceViolationCount_Spread = 0;
int g_complianceViolationCount_Slippage = 0;

//+------------------------------------------------------------------+
//| GLOBAL VARIABLES - LOGGING                                       |
//+------------------------------------------------------------------+
int g_logFileHandle = INVALID_HANDLE;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // Validate symbol
   if(Symbol() != InpSymbol)
   {
      Print("ERROR: EA attached to ", Symbol(), " but configured for ", InpSymbol);
      return INIT_PARAMETERS_INCORRECT;
   }
   
   // Initialize equity trackers
   g_startEquity = AccountEquity();
   g_startDayEquity = g_startEquity;
   g_startWeekEquity = g_startEquity;
   
   // Initialize position state
   ResetManagedPositionState();
   
   // Check for existing position on restart
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == InpSymbol && OrderMagicNumber() == InpMagicNumber)
         {
            ReconstructPositionState();
            break;
         }
      }
   }
   
   // Initialize logging
   if(InpEnableLogging)
   {
      InitializeLogging();
   }
   
   Print("XAUUSD Adaptive MDAE EA (MT4) initialized successfully");
   Print("Compliance Enforcement: Spread=", InpEnforceNoSpreadSlStopMoves, 
         " Slippage=", InpEnforceNoSlippageStopMoves);
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // Close log file
   if(g_logFileHandle != INVALID_HANDLE)
   {
      FileClose(g_logFileHandle);
   }
   
   Print("XAUUSD Adaptive MDAE EA (MT4) deinitialized. Reason: ", reason);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Master EA toggle
   if(!InpEnableEA) return;
   
   // Update daily trackers
   UpdateDailyTrackers();
   
   // Priority 1: Manage existing position first
   if(HasPosition())
   {
      if(InpEnablePositionManagement)
      {
         ManageOpenPosition();
      }
   }
   else
   {
      // No position - reset managed state if needed
      if(g_posState.ticket > 0)
      {
         // Check if position was closed
         if(OrderSelect(g_posState.ticket, SELECT_BY_TICKET, MODE_HISTORY))
         {
            double profit = OrderProfit() + OrderSwap() + OrderCommission();
            if(profit < 0)
            {
               g_consecutiveLosses++;
               LogEvent("DEAL_CLOSED", "Loss detected. Consecutive losses: " + IntegerToString(g_consecutiveLosses));
            }
            else
            {
               g_consecutiveLosses = 0;
               LogEvent("DEAL_CLOSED", "Win detected. Consecutive losses reset.");
            }
         }
         
         ResetManagedPositionState();
      }
   }
   
   // Priority 2: Evaluate new entry on new bar
   if(IsNewBar() && InpEnableEntries)
   {
      EvaluateEntry();
   }
}

//+------------------------------------------------------------------+
//| Check if new bar has formed                                      |
//+------------------------------------------------------------------+
bool IsNewBar()
{
   datetime currentBarTime = iTime(InpSymbol, PERIOD_M1, 0);
   if(currentBarTime != g_lastBarTime)
   {
      g_lastBarTime = currentBarTime;
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Update daily tracking variables                                  |
//+------------------------------------------------------------------+
void UpdateDailyTrackers()
{
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   
   datetime todayStamp = StrToTime(IntegerToString(dt.year) + "." + 
                                   IntegerToString(dt.mon) + "." + 
                                   IntegerToString(dt.day));
   
   if(todayStamp != g_dayStamp)
   {
      // New day - reset counters
      g_dayStamp = todayStamp;
      g_startDayEquity = AccountEquity();
      g_dailyTradeCount = 0;
      g_dailyLockActive = false;
      
      LogEvent("NEW_DAY", "Daily trackers reset");
   }
}

//+------------------------------------------------------------------+
//| Check if trading is locked due to risk conditions                |
//+------------------------------------------------------------------+
bool IsTradingLocked()
{
   if(!InpEnableRiskGovernor) return false;
   
   double currentEquity = AccountEquity();
   
   // Daily drawdown lock
   if(InpEnableDailyDDLock)
   {
      double dailyLoss = g_startDayEquity - currentEquity;
      double dailyLossPercent = (dailyLoss / g_startDayEquity) * 100.0;
      
      if(dailyLossPercent >= InpMaxDailyLossPercent)
      {
         if(!g_dailyLockActive)
         {
            g_dailyLockActive = true;
            LogEvent("RISK_LOCK", "Daily DD lock activated: " + DoubleToString(dailyLossPercent, 2) + "%");
         }
         return true;
      }
   }
   
   // Weekly drawdown lock
   if(InpEnableWeeklyDDLock)
   {
      double weeklyLoss = g_startWeekEquity - currentEquity;
      double weeklyLossPercent = (weeklyLoss / g_startWeekEquity) * 100.0;
      
      if(weeklyLossPercent >= InpMaxWeeklyLossPercent)
      {
         if(!g_weeklyLockActive)
         {
            g_weeklyLockActive = true;
            LogEvent("RISK_LOCK", "Weekly DD lock activated: " + DoubleToString(weeklyLossPercent, 2) + "%");
         }
         return true;
      }
   }
   
   // Consecutive loss lock
   if(InpEnableConsecutiveLossLock)
   {
      if(g_consecutiveLosses >= InpMaxConsecutiveLosses)
      {
         LogEvent("RISK_LOCK", "Consecutive loss lock active: " + IntegerToString(g_consecutiveLosses));
         return true;
      }
   }
   
   // Max trades per day
   if(InpEnableMaxTradesPerSession)
   {
      if(g_dailyTradeCount >= InpMaxTradesPerDay)
      {
         LogEvent("RISK_LOCK", "Max trades per day reached: " + IntegerToString(g_dailyTradeCount));
         return true;
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Check if position exists for our symbol and magic                |
//+------------------------------------------------------------------+
bool HasPosition()
{
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == InpSymbol && OrderMagicNumber() == InpMagicNumber)
         {
            return true;
         }
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| Get position ticket                                              |
//+------------------------------------------------------------------+
int GetPositionTicket()
{
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == InpSymbol && OrderMagicNumber() == InpMagicNumber)
         {
            return OrderTicket();
         }
      }
   }
   return -1;
}

//+------------------------------------------------------------------+
//| Detect current market regime                                     |
//+------------------------------------------------------------------+
ENUM_REGIME DetectRegime()
{
   if(!InpEnableRegimeEngine) return REGIME_NO_TRADE;
   
   // Get ADX values
   double adxCurrent = iADX(InpSymbol, PERIOD_M1, InpADXPeriod, PRICE_CLOSE, MODE_MAIN, 0);
   double adxPrev = iADX(InpSymbol, PERIOD_M1, InpADXPeriod, PRICE_CLOSE, MODE_MAIN, 1);
   
   if(adxCurrent == 0 || adxPrev == 0) return REGIME_NO_TRADE;
   
   double adxSlope = adxCurrent - adxPrev;
   
   // Get Bollinger Bands
   double bbUpper0 = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_UPPER, 0);
   double bbLower0 = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_LOWER, 0);
   double bbMiddle0 = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_MAIN, 0);
   
   double bbUpper1 = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_UPPER, 1);
   double bbLower1 = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_LOWER, 1);
   double bbMiddle1 = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_MAIN, 1);
   
   if(bbMiddle0 == 0 || bbMiddle1 == 0) return REGIME_NO_TRADE;
   
   // Calculate BB width
   double bbWidth = (bbUpper0 - bbLower0) / bbMiddle0;
   double bbWidthPrev = (bbUpper1 - bbLower1) / bbMiddle1;
   bool bbExpanding = bbWidth > bbWidthPrev;
   
   // Regime decision logic
   if(adxCurrent > InpADXTrendThreshold && adxSlope > 0 && 
      bbWidth > InpBBWidthExpansionThreshold && bbExpanding)
   {
      LogEvent("REGIME", "TREND_EXPANSION detected. ADX=" + DoubleToString(adxCurrent, 1) + 
               " BBW=" + DoubleToString(bbWidth, 5));
      return REGIME_TREND_EXPANSION;
   }
   
   if(adxCurrent < InpADXRangeThreshold && 
      bbWidth < InpBBWidthCompressionThreshold)
   {
      LogEvent("REGIME", "MEAN_REVERSION detected. ADX=" + DoubleToString(adxCurrent, 1) + 
               " BBW=" + DoubleToString(bbWidth, 5));
      return REGIME_MEAN_REVERSION;
   }
   
   LogEvent("REGIME", "NO_TRADE - unclear regime");
   return REGIME_NO_TRADE;
}

//+------------------------------------------------------------------+
//| Evaluate trend entry signal                                      |
//+------------------------------------------------------------------+
int EvaluateTrendEntry()
{
   if(!InpEnableTrendModule) return 0;
   
   double emaFast0 = iMA(InpSymbol, PERIOD_M1, InpEMAFastPeriod, 0, MODE_EMA, PRICE_CLOSE, 0);
   double emaFast1 = iMA(InpSymbol, PERIOD_M1, InpEMAFastPeriod, 0, MODE_EMA, PRICE_CLOSE, 1);
   double emaSlow0 = iMA(InpSymbol, PERIOD_M1, InpEMASlowPeriod, 0, MODE_EMA, PRICE_CLOSE, 0);
   double emaSlow1 = iMA(InpSymbol, PERIOD_M1, InpEMASlowPeriod, 0, MODE_EMA, PRICE_CLOSE, 1);
   
   double rsi0 = iRSI(InpSymbol, PERIOD_M1, InpRSIPeriod, PRICE_CLOSE, 0);
   
   double close0 = iClose(InpSymbol, PERIOD_M1, 0);
   double close1 = iClose(InpSymbol, PERIOD_M1, 1);
   
   // Long setup: EMA fast > EMA slow, pullback recovery, RSI not overbought
   if(emaFast0 > emaSlow0 && emaFast1 > emaSlow1)
   {
      if(close1 < emaFast1 && close0 > emaFast0) // Pullback recovery
      {
         if(rsi0 < InpRSIOverboughtLevel && rsi0 > 50.0)
         {
            LogEvent("SIGNAL", "LONG trend signal detected");
            return 1;
         }
      }
   }
   
   // Short setup: EMA fast < EMA slow, pullback recovery, RSI not oversold
   if(emaFast0 < emaSlow0 && emaFast1 < emaSlow1)
   {
      if(close1 > emaFast1 && close0 < emaFast0) // Pullback recovery
      {
         if(rsi0 > InpRSIOversoldLevel && rsi0 < 50.0)
         {
            LogEvent("SIGNAL", "SHORT trend signal detected");
            return -1;
         }
      }
   }
   
   return 0;
}

//+------------------------------------------------------------------+
//| Evaluate mean reversion entry signal                             |
//+------------------------------------------------------------------+
int EvaluateMeanReversionEntry()
{
   if(!InpEnableMeanReversionModule) return 0;
   
   double bbUpper0 = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_UPPER, 0);
   double bbLower0 = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_LOWER, 0);
   double bbUpper1 = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_UPPER, 1);
   double bbLower1 = iBands(InpSymbol, PERIOD_M1, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_LOWER, 1);
   
   double rsi0 = iRSI(InpSymbol, PERIOD_M1, InpRSIPeriod, PRICE_CLOSE, 0);
   
   double close0 = iClose(InpSymbol, PERIOD_M1, 0);
   double close1 = iClose(InpSymbol, PERIOD_M1, 1);
   
   // Long setup: touch/breach lower band then rejection, RSI oversold
   if(close1 <= bbLower1 && close0 > bbLower0)
   {
      if(rsi0 < InpRSIOversoldLevel)
      {
         LogEvent("SIGNAL", "LONG mean reversion signal detected");
         return 1;
      }
   }
   
   // Short setup: touch/breach upper band then rejection, RSI overbought
   if(close1 >= bbUpper1 && close0 < bbUpper0)
   {
      if(rsi0 > InpRSIOverboughtLevel)
      {
         LogEvent("SIGNAL", "SHORT mean reversion signal detected");
         return -1;
      }
   }
   
   return 0;
}

//+------------------------------------------------------------------+
//| Check session filter                                             |
//+------------------------------------------------------------------+
bool IsWithinTradingSession()
{
   if(!InpEnableSessionFilter) return true;
   
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   
   if(dt.hour >= InpSessionStartHour && dt.hour < InpSessionEndHour)
   {
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Check spread filter                                              |
//+------------------------------------------------------------------+
bool IsSpreadAcceptable()
{
   if(!InpEnableSpreadEntryFilter) return true;
   
   double spreadPoints = (Ask - Bid) / Point;
   
   if(spreadPoints > InpMaxSpreadPoints)
   {
      LogEvent("FILTER", "Spread too high: " + DoubleToString(spreadPoints, 1) + " points");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Evaluate entry conditions                                        |
//+------------------------------------------------------------------+
void EvaluateEntry()
{
   // Check if position already exists
   if(InpEnableOnePositionOnly && HasPosition())
   {
      return;
   }
   
   // Check trading locks
   if(IsTradingLocked())
   {
      return;
   }
   
   // Check session filter
   if(!IsWithinTradingSession())
   {
      return;
   }
   
   // Check spread filter
   if(!IsSpreadAcceptable())
   {
      return;
   }
   
   // Detect regime
   ENUM_REGIME regime = DetectRegime();
   if(regime == REGIME_NO_TRADE)
   {
      return;
   }
   
   // Evaluate setup signals
   int signal = 0;
   
   if(regime == REGIME_TREND_EXPANSION)
   {
      signal = EvaluateTrendEntry();
   }
   else if(regime == REGIME_MEAN_REVERSION)
   {
      signal = EvaluateMeanReversionEntry();
   }
   
   // Execute entry if signal valid
   if(signal != 0)
   {
      ExecuteEntry(signal, regime);
   }
}

//+------------------------------------------------------------------+
//| Execute entry order                                              |
//+------------------------------------------------------------------+
void ExecuteEntry(int direction, ENUM_REGIME regime)
{
   // Get ATR for stop calculation
   double atrValue = iATR(InpSymbol, PERIOD_M1, InpATRPeriod, 0);
   if(atrValue == 0)
   {
      LogEvent("ERROR", "Failed to get ATR for entry");
      return;
   }
   
   // Calculate stop loss distance
   double slDistance = atrValue * InpATRStopMultiplier;
   double slDistancePoints = slDistance / Point;
   
   // Apply min/max constraints
   if(slDistancePoints < InpMinStopPoints) slDistancePoints = InpMinStopPoints;
   if(slDistancePoints > InpMaxStopPoints) slDistancePoints = InpMaxStopPoints;
   
   slDistance = slDistancePoints * Point;
   
   // Calculate position size
   double riskMoney = AccountEquity() * (InpRiskPercent / 100.0);
   double tickValue = MarketInfo(InpSymbol, MODE_TICKVALUE);
   double tickSize = MarketInfo(InpSymbol, MODE_TICKSIZE);
   double lotSize = (riskMoney / slDistance) * (tickSize / tickValue);
   
   // Normalize lot size
   double minLot = MarketInfo(InpSymbol, MODE_MINLOT);
   double maxLot = MarketInfo(InpSymbol, MODE_MAXLOT);
   double lotStep = MarketInfo(InpSymbol, MODE_LOTSTEP);
   
   lotSize = MathFloor(lotSize / lotStep) * lotStep;
   if(lotSize < minLot) lotSize = minLot;
   if(lotSize > maxLot) lotSize = maxLot;
   
   // Get current price
   double price = (direction > 0) ? Ask : Bid;
   
   // Calculate SL and TP
   double sl = (direction > 0) ? (price - slDistance) : (price + slDistance);
   double tp = 0; // Managed dynamically
   
   // Normalize prices
   int digits = (int)MarketInfo(InpSymbol, MODE_DIGITS);
   sl = NormalizeDouble(sl, digits);
   price = NormalizeDouble(price, digits);
   
   // Place order
   int ticket = -1;
   string comment = "MDAE " + ((direction > 0) ? "Long" : "Short");
   
   if(direction > 0)
   {
      ticket = OrderSend(InpSymbol, OP_BUY, lotSize, price, InpSlippage, sl, tp, comment, InpMagicNumber, 0, clrGreen);
   }
   else
   {
      ticket = OrderSend(InpSymbol, OP_SELL, lotSize, price, InpSlippage, sl, tp, comment, InpMagicNumber, 0, clrRed);
   }
   
   // Handle result
   if(ticket > 0)
   {
      g_dailyTradeCount++;
      
      // Get actual entry price
      if(OrderSelect(ticket, SELECT_BY_TICKET))
      {
         double actualEntry = OrderOpenPrice();
         double actualSL = OrderStopLoss();
         double actualVol = OrderLots();
         
         // Initialize managed position state
         InitializeManagedPositionState(ticket, actualEntry, actualSL, slDistance, actualVol, direction);
         
         LogEvent("ENTRY", "Order opened. Ticket=" + IntegerToString(ticket) + 
                  " Direction=" + IntegerToString(direction) + 
                  " Lot=" + DoubleToString(lotSize, 2) +
                  " SL Distance=" + DoubleToString(slDistancePoints, 1) + " points");
      }
   }
   else
   {
      int errorCode = GetLastError();
      LogEvent("ERROR", "Order failed. Code=" + IntegerToString(errorCode) +
               " Desc=" + ErrorDescription(errorCode));
   }
}

//+------------------------------------------------------------------+
//| Initialize managed position state                                |
//+------------------------------------------------------------------+
void InitializeManagedPositionState(int ticket, double entry, double sl, double slDist, double vol, int dir)
{
   g_posState.ticket = ticket;
   g_posState.entryPrice = entry;
   g_posState.initialStopLoss = sl;
   g_posState.initialRiskDistance = slDist;
   g_posState.initialVolume = vol;
   g_posState.entryTime = TimeCurrent();
   g_posState.entryBar = 0;
   
   g_posState.beActivated = false;
   g_posState.partial1Done = false;
   g_posState.partial2Done = false;
   g_posState.partial3Done = false;
   
   g_posState.activeMethod = CM_FIXED;
   g_posState.policySwitchCount = 0;
   
   g_posState.maxFavorableExcursion = 0.0;
   g_posState.maxAdverseExcursion = 0.0;
   g_posState.ageInBars = 0;
   
   g_posState.lastTrailPrice = 0.0;
}

//+------------------------------------------------------------------+
//| Reset managed position state                                     |
//+------------------------------------------------------------------+
void ResetManagedPositionState()
{
   g_posState.ticket = 0;
   g_posState.entryPrice = 0;
   g_posState.initialStopLoss = 0;
   g_posState.initialRiskDistance = 0;
   g_posState.initialVolume = 0;
   g_posState.entryTime = 0;
   g_posState.entryBar = 0;
   
   g_posState.beActivated = false;
   g_posState.partial1Done = false;
   g_posState.partial2Done = false;
   g_posState.partial3Done = false;
   
   g_posState.activeMethod = CM_FIXED;
   g_posState.policySwitchCount = 0;
   
   g_posState.maxFavorableExcursion = 0.0;
   g_posState.maxAdverseExcursion = 0.0;
   g_posState.ageInBars = 0;
   
   g_posState.lastTrailPrice = 0.0;
}

//+------------------------------------------------------------------+
//| Reconstruct position state on restart                            |
//+------------------------------------------------------------------+
void ReconstructPositionState()
{
   int ticket = GetPositionTicket();
   if(ticket < 0) return;
   
   if(!OrderSelect(ticket, SELECT_BY_TICKET)) return;
   
   double entryPrice = OrderOpenPrice();
   double currentSL = OrderStopLoss();
   double volume = OrderLots();
   datetime openTime = OrderOpenTime();
   int orderType = OrderType();
   
   g_posState.ticket = ticket;
   g_posState.entryPrice = entryPrice;
   g_posState.initialStopLoss = currentSL;
   g_posState.initialRiskDistance = MathAbs(entryPrice - currentSL);
   g_posState.initialVolume = volume;
   g_posState.entryTime = openTime;
   g_posState.entryBar = 0;
   
   // Infer BE status
   if(orderType == OP_BUY)
   {
      g_posState.beActivated = (currentSL >= entryPrice);
   }
   else
   {
      g_posState.beActivated = (currentSL <= entryPrice);
   }
   
   // Cannot reliably infer partial states
   g_posState.partial1Done = false;
   g_posState.partial2Done = false;
   g_posState.partial3Done = false;
   
   g_posState.activeMethod = CM_FIXED;
   g_posState.policySwitchCount = 0;
   
   g_posState.maxFavorableExcursion = 0.0;
   g_posState.maxAdverseExcursion = 0.0;
   g_posState.ageInBars = 0;
   
   LogEvent("RECONSTRUCT", "Position state reconstructed. Ticket=" + IntegerToString(ticket));
}

//+------------------------------------------------------------------+
//| Manage open position                                             |
//+------------------------------------------------------------------+
void ManageOpenPosition()
{
   int ticket = GetPositionTicket();
   if(ticket < 0) return;
   
   if(!OrderSelect(ticket, SELECT_BY_TICKET)) return;
   
   // Update position metrics
   double currentPrice = (OrderType() == OP_BUY) ? Bid : Ask;
   double entryPrice = g_posState.entryPrice;
   double currentSL = OrderStopLoss();
   double currentVolume = OrderLots();
   int orderType = OrderType();
   int direction = (orderType == OP_BUY) ? 1 : -1;
   
   // Calculate R-multiple
   double riskDistance = g_posState.initialRiskDistance;
   double priceMove = (direction > 0) ? (currentPrice - entryPrice) : (entryPrice - currentPrice);
   double currentR = (riskDistance > 0) ? (priceMove / riskDistance) : 0.0;
   
   // Update MFE/MAE
   if(currentR > g_posState.maxFavorableExcursion)
   {
      g_posState.maxFavorableExcursion = currentR;
   }
   if(currentR < g_posState.maxAdverseExcursion)
   {
      g_posState.maxAdverseExcursion = currentR;
   }
   
   // Update age
   g_posState.ageInBars++;
   
   // Check invalidation exit
   if(InpEnableInvalidationExit && CheckInvalidationExit(direction, currentR))
   {
      ClosePosition("Invalidation exit");
      return;
   }
   
   // Check time stop
   if(InpEnableTimeStop && g_posState.ageInBars > InpMaxTradeAgeBars)
   {
      ClosePosition("Time stop - max age reached");
      return;
   }
   
   // Select close method (MDAE)
   if(InpEnableMDAE)
   {
      int newMethod = ChooseCloseMethod(direction, currentR);
      
      if(InpEnablePolicySwitching && newMethod != g_posState.activeMethod)
      {
         if(g_posState.policySwitchCount < InpMaxPolicySwitches)
         {
            g_posState.activeMethod = newMethod;
            g_posState.policySwitchCount++;
            LogEvent("MDAE", "Policy switched to method " + IntegerToString(newMethod) + 
                     " (switch #" + IntegerToString(g_posState.policySwitchCount) + ")");
         }
      }
   }
   
   // Execute partial closes
   if(InpEnablePartialClose)
   {
      ExecutePartialCloses(currentR, currentVolume);
   }
   
   // Execute break even
   if(InpEnableBreakEven)
   {
      ExecuteBreakEven(currentR, direction);
   }
   
   // Execute trailing
   ExecuteTrailing(direction, currentR, currentPrice, currentSL);
}

//+------------------------------------------------------------------+
//| Check invalidation exit conditions                               |
//+------------------------------------------------------------------+
bool CheckInvalidationExit(int direction, double currentR)
{
   // RSI invalidation
   double rsi0 = iRSI(InpSymbol, PERIOD_M1, InpRSIPeriod, PRICE_CLOSE, 0);
   
   if(direction > 0 && rsi0 < InpInvalidationRSIThreshold && currentR < 0.5)
   {
      LogEvent("INVALIDATION", "Long thesis invalidated - RSI below threshold");
      return true;
   }
   if(direction < 0 && rsi0 > (100.0 - InpInvalidationRSIThreshold) && currentR < 0.5)
   {
      LogEvent("INVALIDATION", "Short thesis invalidated - RSI above threshold");
      return true;
   }
   
   // Regime flip invalidation
   ENUM_REGIME currentRegime = DetectRegime();
   if(currentRegime == REGIME_NO_TRADE && currentR < 1.0)
   {
      LogEvent("INVALIDATION", "Regime turned NO_TRADE with low profit");
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Choose close method based on MDAE features                       |
//+------------------------------------------------------------------+
int ChooseCloseMethod(int direction, double currentR)
{
   // Calculate MDAE features
   double speedRatio = CalculateSpeedRatio();
   double volumePulse = CalculateVolumePulse();
   bool top2Breakout = CheckTop2Breakout(direction);
   bool inLowVolumeBox = CheckLowVolumeBox();
   double entropy = CalculateEntropy(speedRatio, volumePulse);
   
   // Decision logic
   if(InpEnableFastBankMode && currentR >= InpFastBankTriggerR && entropy > InpEntropyThreshold)
   {
      return CM_FAST_BANK;
   }
   
   if(InpEnableEntropyScoring && entropy > InpEntropyThreshold)
   {
      return CM_HYBRID;
   }
   
   if(InpEnablePipsPerSecond && speedRatio > 1.5 && InpEnableTop2BreakoutCheck && top2Breakout)
   {
      if(InpEnableSwingTrail)
         return CM_STRUCTURE_TRAIL;
   }
   
   if(InpEnableATRTrail && speedRatio > 1.0)
   {
      return CM_ATR_TRAIL;
   }
   
   if(InpEnableLowVolumeBox && inLowVolumeBox)
   {
      return CM_FIXED;
   }
   
   // Default to hybrid if enabled, otherwise fixed
   if(InpEnableHybridCloseMode)
      return CM_HYBRID;
   
   return CM_FIXED;
}

//+------------------------------------------------------------------+
//| Calculate speed ratio                                            |
//+------------------------------------------------------------------+
double CalculateSpeedRatio()
{
   if(!InpEnablePipsPerSecond) return 1.0;
   
   double recentMove = MathAbs(iClose(InpSymbol, PERIOD_M1, 0) - iClose(InpSymbol, PERIOD_M1, 1)) / Point;
   
   double avgMove = 0.0;
   for(int i = 1; i <= InpMDAE_SpeedWindow; i++)
   {
      avgMove += MathAbs(iClose(InpSymbol, PERIOD_M1, i) - iClose(InpSymbol, PERIOD_M1, i+1)) / Point;
   }
   avgMove /= InpMDAE_SpeedWindow;
   
   return (avgMove > 0) ? (recentMove / avgMove) : 1.0;
}

//+------------------------------------------------------------------+
//| Calculate volume pulse                                           |
//+------------------------------------------------------------------+
double CalculateVolumePulse()
{
   if(!InpEnableVolumePulse) return 1.0;
   
   long recentVol = iVolume(InpSymbol, PERIOD_M1, 0);
   
   double avgVol = 0.0;
   for(int i = 1; i <= InpMDAE_VolumeWindow; i++)
   {
      avgVol += (double)iVolume(InpSymbol, PERIOD_M1, i);
   }
   avgVol /= InpMDAE_VolumeWindow;
   
   return (avgVol > 0) ? (recentVol / avgVol) : 1.0;
}

//+------------------------------------------------------------------+
//| Check top2 breakout                                              |
//+------------------------------------------------------------------+
bool CheckTop2Breakout(int direction)
{
   if(!InpEnableTop2BreakoutCheck) return false;
   
   // Find highest high and lowest low in lookback
   double maxHigh = iHigh(InpSymbol, PERIOD_M1, 1);
   double minLow = iLow(InpSymbol, PERIOD_M1, 1);
   
   for(int i = 2; i <= InpMDAE_Top2Lookback; i++)
   {
      double h = iHigh(InpSymbol, PERIOD_M1, i);
      double l = iLow(InpSymbol, PERIOD_M1, i);
      if(h > maxHigh) maxHigh = h;
      if(l < minLow) minLow = l;
   }
   
   double currentHigh = iHigh(InpSymbol, PERIOD_M1, 0);
   double currentLow = iLow(InpSymbol, PERIOD_M1, 0);
   
   if(direction > 0 && currentHigh > maxHigh) return true;
   if(direction < 0 && currentLow < minLow) return true;
   
   return false;
}

//+------------------------------------------------------------------+
//| Check low volume box                                             |
//+------------------------------------------------------------------+
bool CheckLowVolumeBox()
{
   if(!InpEnableLowVolumeBox) return false;
   
   // Calculate average volume
   double avgVol = 0.0;
   for(int i = 0; i < InpMDAE_LVBoxLookback; i++)
   {
      avgVol += (double)iVolume(InpSymbol, PERIOD_M1, i);
   }
   avgVol /= InpMDAE_LVBoxLookback;
   
   // Check if recent volume is consistently low
   int lowVolCount = 0;
   for(int i = 0; i < 5; i++)
   {
      if((double)iVolume(InpSymbol, PERIOD_M1, i) < avgVol * InpMDAE_LVBoxVolumeThreshold)
         lowVolCount++;
   }
   
   return (lowVolCount >= 3);
}

//+------------------------------------------------------------------+
//| Calculate entropy score                                          |
//+------------------------------------------------------------------+
double CalculateEntropy(double speedRatio, double volumePulse)
{
   if(!InpEnableEntropyScoring) return 0.0;
   
   double entropy = 0.0;
   
   if(speedRatio < 0.8 && volumePulse > 1.2) entropy += 0.3;
   if(speedRatio > 1.2 && volumePulse < 0.8) entropy += 0.3;
   
   double rsi0 = iRSI(InpSymbol, PERIOD_M1, InpRSIPeriod, PRICE_CLOSE, 0);
   double rsi1 = iRSI(InpSymbol, PERIOD_M1, InpRSIPeriod, PRICE_CLOSE, 1);
   double rsiChange = MathAbs(rsi0 - rsi1);
   if(rsiChange > 10.0) entropy += 0.2;
   
   if(CheckLowVolumeBox()) entropy += 0.2;
   
   return MathMin(entropy, 1.0);
}

//+------------------------------------------------------------------+
//| Execute partial closes                                           |
//+------------------------------------------------------------------+
void ExecutePartialCloses(double currentR, double currentVolume)
{
   double minLot = MarketInfo(InpSymbol, MODE_MINLOT);
   double lotStep = MarketInfo(InpSymbol, MODE_LOTSTEP);
   
   // Partial 1 at TP1
   if(!g_posState.partial1Done && currentR >= InpTP1_RMultiple)
   {
      double closePercent = InpPartial1Percent / 100.0;
      double closeVolume = currentVolume * closePercent;
      closeVolume = MathFloor(closeVolume / lotStep) * lotStep;
      
      if(closeVolume >= minLot && closeVolume < currentVolume)
      {
         if(ClosePartial(closeVolume))
         {
            g_posState.partial1Done = true;
            LogEvent("PARTIAL", "Partial 1 closed at " + DoubleToString(currentR, 2) + "R. Volume=" + 
                     DoubleToString(closeVolume, 2));
         }
      }
   }
   
   // Partial 2 at TP2
   if(!g_posState.partial2Done && g_posState.partial1Done && currentR >= InpTP2_RMultiple)
   {
      // Refresh volume
      if(OrderSelect(g_posState.ticket, SELECT_BY_TICKET))
      {
         currentVolume = OrderLots();
      }
      
      double closePercent = InpPartial2Percent / 100.0;
      double closeVolume = currentVolume * closePercent;
      closeVolume = MathFloor(closeVolume / lotStep) * lotStep;
      
      if(closeVolume >= minLot && closeVolume < currentVolume)
      {
         if(ClosePartial(closeVolume))
         {
            g_posState.partial2Done = true;
            LogEvent("PARTIAL", "Partial 2 closed at " + DoubleToString(currentR, 2) + "R. Volume=" + 
                     DoubleToString(closeVolume, 2));
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Close partial position                                           |
//+------------------------------------------------------------------+
bool ClosePartial(double volume)
{
   if(!OrderSelect(g_posState.ticket, SELECT_BY_TICKET)) return false;
   
   double price = (OrderType() == OP_BUY) ? Bid : Ask;
   
   bool result = OrderClose(g_posState.ticket, volume, price, InpSlippage, clrOrange);
   
   if(!result)
   {
      int errorCode = GetLastError();
      LogEvent("ERROR", "Partial close failed. Code=" + IntegerToString(errorCode));
   }
   
   return result;
}

//+------------------------------------------------------------------+
//| Execute break even                                               |
//+------------------------------------------------------------------+
void ExecuteBreakEven(double currentR, int direction)
{
   if(g_posState.beActivated) return;
   if(currentR < InpBreakEvenTriggerR) return;
   if(g_posState.ageInBars < InpMinBarsBeforeBE) return;
   
   if(!OrderSelect(g_posState.ticket, SELECT_BY_TICKET)) return;
   
   double currentSL = OrderStopLoss();
   double entryPrice = g_posState.entryPrice;
   int digits = (int)MarketInfo(InpSymbol, MODE_DIGITS);
   
   double newSL = entryPrice + (direction * InpBreakEvenBufferPoints * Point);
   newSL = NormalizeDouble(newSL, digits);
   
   // Validate move
   bool validMove = false;
   if(direction > 0 && newSL > currentSL) validMove = true;
   if(direction < 0 && newSL < currentSL) validMove = true;
   
   if(validMove)
   {
      if(ModifyPositionSL(newSL))
      {
         g_posState.beActivated = true;
         LogEvent("BREAKEVEN", "Break even activated at " + DoubleToString(currentR, 2) + "R");
      }
   }
}

//+------------------------------------------------------------------+
//| Execute trailing logic                                           |
//+------------------------------------------------------------------+
void ExecuteTrailing(int direction, double currentR, double currentPrice, double currentSL)
{
   if(currentR < 1.0) return;
   
   double newSL = currentSL;
   bool shouldUpdate = false;
   
   switch(g_posState.activeMethod)
   {
      case CM_ATR_TRAIL:
         if(InpEnableATRTrail)
         {
            double atrValue = iATR(InpSymbol, PERIOD_M1, InpATRPeriod, 0);
            if(atrValue > 0)
            {
               double trailDistance = atrValue * InpATRTrailMultiplier;
               double candidateSL = (direction > 0) ? (currentPrice - trailDistance) : 
                                                       (currentPrice + trailDistance);
               
               if(direction > 0 && candidateSL > currentSL)
               {
                  newSL = candidateSL;
                  shouldUpdate = true;
               }
               if(direction < 0 && candidateSL < currentSL)
               {
                  newSL = candidateSL;
                  shouldUpdate = true;
               }
            }
         }
         break;
         
      case CM_STRUCTURE_TRAIL:
         if(InpEnableSwingTrail)
         {
            double swingSL = CalculateSwingTrailSL(direction);
            if(swingSL > 0)
            {
               if(direction > 0 && swingSL > currentSL)
               {
                  newSL = swingSL;
                  shouldUpdate = true;
               }
               if(direction < 0 && swingSL < currentSL)
               {
                  newSL = swingSL;
                  shouldUpdate = true;
               }
            }
         }
         break;
         
      case CM_FAST_BANK:
         if(InpEnableFastBankMode && currentR > InpFastBankProtectR)
         {
            double protectDistance = g_posState.initialRiskDistance * InpFastBankProtectR;
            double protectSL = (direction > 0) ? (currentPrice - protectDistance) : 
                                                  (currentPrice + protectDistance);
            
            if(direction > 0 && protectSL > currentSL)
            {
               newSL = protectSL;
               shouldUpdate = true;
            }
            if(direction < 0 && protectSL < currentSL)
            {
               newSL = protectSL;
               shouldUpdate = true;
            }
         }
         break;
         
      case CM_HYBRID:
         // Use ATR trail as hybrid default
         if(InpEnableATRTrail)
         {
            double atrValue = iATR(InpSymbol, PERIOD_M1, InpATRPeriod, 0);
            if(atrValue > 0)
            {
               double trailDistance = atrValue * InpATRTrailMultiplier;
               double candidateSL = (direction > 0) ? (currentPrice - trailDistance) : 
                                                       (currentPrice + trailDistance);
               
               if(direction > 0 && candidateSL > currentSL)
               {
                  newSL = candidateSL;
                  shouldUpdate = true;
               }
               if(direction < 0 && candidateSL < currentSL)
               {
                  newSL = candidateSL;
                  shouldUpdate = true;
               }
            }
         }
         break;
   }
   
   if(shouldUpdate)
   {
      int digits = (int)MarketInfo(InpSymbol, MODE_DIGITS);
      newSL = NormalizeDouble(newSL, digits);
      
      if(ModifyPositionSL(newSL))
      {
         LogEvent("TRAIL", "SL trailed by method " + IntegerToString(g_posState.activeMethod) + 
                  " to " + DoubleToString(newSL, digits));
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate swing trail SL                                         |
//+------------------------------------------------------------------+
double CalculateSwingTrailSL(int direction)
{
   double swingLevel = 0;
   
   if(direction > 0)
   {
      swingLevel = iLow(InpSymbol, PERIOD_M1, 1);
      for(int i = 2; i <= InpSwingLookbackBars; i++)
      {
         double low = iLow(InpSymbol, PERIOD_M1, i);
         if(low < swingLevel) swingLevel = low;
      }
   }
   else
   {
      swingLevel = iHigh(InpSymbol, PERIOD_M1, 1);
      for(int i = 2; i <= InpSwingLookbackBars; i++)
      {
         double high = iHigh(InpSymbol, PERIOD_M1, i);
         if(high > swingLevel) swingLevel = high;
      }
   }
   
   return swingLevel;
}

//+------------------------------------------------------------------+
//| Modify position SL                                               |
//+------------------------------------------------------------------+
bool ModifyPositionSL(double newSL)
{
   if(!OrderSelect(g_posState.ticket, SELECT_BY_TICKET)) return false;
   
   // COMPLIANCE CHECK: Only called by strategy logic
   if(InpEnableComplianceAuditCounters)
   {
      // No spread/slippage-triggered modification here
   }
   
   double currentTP = OrderTakeProfit();
   bool result = OrderModify(g_posState.ticket, OrderOpenPrice(), newSL, currentTP, 0, clrBlue);
   
   if(!result)
   {
      int errorCode = GetLastError();
      LogEvent("ERROR", "SL modify failed. Code=" + IntegerToString(errorCode));
   }
   
   return result;
}

//+------------------------------------------------------------------+
//| Close position completely                                        |
//+------------------------------------------------------------------+
void ClosePosition(string reason)
{
   if(!OrderSelect(g_posState.ticket, SELECT_BY_TICKET)) return;
   
   double price = (OrderType() == OP_BUY) ? Bid : Ask;
   double volume = OrderLots();
   
   bool result = OrderClose(g_posState.ticket, volume, price, InpSlippage, clrRed);
   
   if(result)
   {
      LogEvent("EXIT", "Position closed. Reason: " + reason + 
               " MFE=" + DoubleToString(g_posState.maxFavorableExcursion, 2) + "R" +
               " MAE=" + DoubleToString(g_posState.maxAdverseExcursion, 2) + "R");
      
      ResetManagedPositionState();
   }
   else
   {
      int errorCode = GetLastError();
      LogEvent("ERROR", "Close failed. Code=" + IntegerToString(errorCode));
   }
}

//+------------------------------------------------------------------+
//| Initialize logging                                               |
//+------------------------------------------------------------------+
void InitializeLogging()
{
   string filename = "XAUUSD_MDAE_" + IntegerToString(InpMagicNumber) + "_" + 
                     TimeToString(TimeCurrent(), TIME_DATE) + ".log";
   
   g_logFileHandle = FileOpen(filename, FILE_WRITE|FILE_TXT|FILE_ANSI|FILE_SHARE_READ);
   
   if(g_logFileHandle != INVALID_HANDLE)
   {
      FileWrite(g_logFileHandle, "=== XAUUSD Adaptive MDAE EA Log (MT4) ===");
      FileWrite(g_logFileHandle, "Start Time: " + TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS));
      FileWrite(g_logFileHandle, "Magic Number: " + IntegerToString(InpMagicNumber));
      FileWrite(g_logFileHandle, "");
   }
}

//+------------------------------------------------------------------+
//| Log event                                                        |
//+------------------------------------------------------------------+
void LogEvent(string eventType, string message)
{
   if(!InpEnableLogging) return;
   
   string timestamp = TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS);
   string logLine = timestamp + " [" + eventType + "] " + message;
   
   if(InpEnableDebugPrints)
   {
      Print(logLine);
   }
   
   if(g_logFileHandle != INVALID_HANDLE)
   {
      FileWrite(g_logFileHandle, logLine);
      FileFlush(g_logFileHandle);
   }
}

//+------------------------------------------------------------------+
//| Error description helper                                         |
//+------------------------------------------------------------------+
string ErrorDescription(int errorCode)
{
   switch(errorCode)
   {
      case 0:   return "No error";
      case 1:   return "No error, trade conditions not changed";
      case 2:   return "Common error";
      case 3:   return "Invalid trade parameters";
      case 4:   return "Trade server is busy";
      case 5:   return "Old version of the client terminal";
      case 6:   return "No connection with trade server";
      case 7:   return "Not enough rights";
      case 8:   return "Too frequent requests";
      case 9:   return "Malfunctional trade operation";
      case 64:  return "Account disabled";
      case 65:  return "Invalid account";
      case 128: return "Trade timeout";
      case 129: return "Invalid price";
      case 130: return "Invalid stops";
      case 131: return "Invalid trade volume";
      case 132: return "Market is closed";
      case 133: return "Trade is disabled";
      case 134: return "Not enough money";
      case 135: return "Price changed";
      case 136: return "Off quotes";
      case 137: return "Broker is busy";
      case 138: return "Requote";
      case 139: return "Order is locked";
      case 140: return "Long positions only allowed";
      case 141: return "Too many requests";
      case 145: return "Modification denied because order too close to market";
      case 146: return "Trade context is busy";
      case 147: return "Expirations are denied by broker";
      case 148: return "Amount of open and pending orders has reached the limit";
      default:  return "Unknown error " + IntegerToString(errorCode);
   }
}
//+------------------------------------------------------------------+      list all the errors and problems of the codes are they perfect? 
