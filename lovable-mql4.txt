//+------------------------------------------------------------------+ 
//+------------------------------------------------------------------+
//|                        XAUUSD_Adaptive_MDAE_EA.mq4               |
//|       Production-Grade Adaptive MDAE Expert Advisor for MT4      |
//|           Version 1.0 — Full Implementation, No Placeholders     |
//+------------------------------------------------------------------+
//| MT4 LIMITATIONS ANNOTATED:                                       |
//|  - No CTrade class; uses OrderSend/OrderModify/OrderClose        |
//|  - No PositionSelectByTicket; iterates OrdersTotal()             |
//|  - No OnTradeTransaction; loss tracking in OnTick                |
//|  - No iADX multi-buffer; uses iADX() direct calls               |
//|  - No grouped inputs; uses comment-based grouping                |
//|  - No ORDER_FILLING modes; handled natively by MT4               |
//|  - No SymbolInfoInteger for SYMBOL_TRADE_FREEZE_LEVEL in old MT4 |
//+------------------------------------------------------------------+
#property copyright "XAUUSD Adaptive MDAE"
#property link      ""
#property version   "1.00"
#property strict
//+------------------------------------------------------------------+
//| ENUMERATIONS                                                     |
//+------------------------------------------------------------------+
enum ENUM_REGIME
{
   REGIME_NO_TRADE        = 0,
   REGIME_TREND_EXPANSION = 1,
   REGIME_MEAN_REVERSION  = 2
};
enum ENUM_CLOSE_METHOD
{
   CM_FIXED  = 0,
   CM_ATR    = 1,
   CM_SWING  = 2,
   CM_FAST   = 3,
   CM_EXIT   = 4,
   CM_HYBRID = 5
};
enum ENUM_RISK_STATE
{
   RISK_ALLOW  = 0,
   RISK_REDUCE = 1,
   RISK_BLOCK  = 2
};
//+------------------------------------------------------------------+
//| INPUTS — MASTER TOGGLES                                          |
//+------------------------------------------------------------------+
// --- Master Toggles ---
extern bool   EnableEA                     = true;
extern bool   EnableEntries                = true;
extern bool   EnablePositionManagement     = true;
extern bool   EnableLogging                = true;
extern bool   EnableDebugPrints            = false;
//+------------------------------------------------------------------+
//| INPUTS — REGIME / ENTRY TOGGLES                                  |
//+------------------------------------------------------------------+
// --- Regime & Entry Toggles ---
extern bool   EnableRegimeEngine           = true;
extern bool   EnableTrendModule            = true;
extern bool   EnableMeanReversionModule    = true;
extern bool   EnableNoTradeState           = true;
extern bool   EnableMTFContextCheck        = true;
extern bool   EnableVWAPCheck              = false;
extern bool   EnableSessionFilter          = true;
extern bool   EnableNewsWindowBlock        = false;
//+------------------------------------------------------------------+
//| INPUTS — RISK / EXECUTION TOGGLES                                |
//+------------------------------------------------------------------+
// --- Risk & Execution Toggles ---
extern bool   EnableRiskGovernor           = true;
extern bool   EnableDailyDDLock            = true;
extern bool   EnableWeeklyDDLock           = true;
extern bool   EnableConsecutiveLossLock    = true;
extern bool   EnableSpreadEntryFilter      = true;
extern bool   EnableSlippageEntryFilter    = true;
extern bool   EnableOnePositionOnly        = true;
extern bool   EnableMaxTradesPerSession    = true;
//+------------------------------------------------------------------+
//| INPUTS — MDAE FEATURE TOGGLES                                    |
//+------------------------------------------------------------------+
// --- MDAE Feature Toggles ---
extern bool   EnableMDAE                   = true;
extern bool   EnablePipsPerSecond          = true;
extern bool   EnableVolumePulse            = true;
extern bool   EnableBodyExpansion          = true;
extern bool   EnableTop2BreakoutCheck      = true;
extern bool   EnableLowVolumeBox           = true;
extern bool   EnableFibGuidance            = false;
extern bool   EnableEntropyScoring         = true;
extern bool   EnablePolicySwitching        = true;
//+------------------------------------------------------------------+
//| INPUTS — EXIT / ACTION TOGGLES                                   |
//+------------------------------------------------------------------+
// --- Exit & Action Toggles ---
extern bool   EnablePartialClose           = true;
extern bool   EnableBreakEven              = true;
extern bool   EnableATRTrail               = true;
extern bool   EnableSwingTrail             = true;
extern bool   EnableFastBankMode           = true;
extern bool   EnableHybridCloseMode        = true;
extern bool   EnableInvalidationExit       = true;
extern bool   EnableTimeStop               = true;
//+------------------------------------------------------------------+
//| INPUTS — COMPLIANCE TOGGLES                                      |
//+------------------------------------------------------------------+
// --- Compliance Toggles ---
extern bool   EnforceNoSpreadSlStopMoves   = true;
extern bool   EnforceNoSlippageStopMoves   = true;
extern bool   EnableComplianceAuditCounters= true;
//+------------------------------------------------------------------+
//| INPUTS — SYMBOL & CORE                                           |
//+------------------------------------------------------------------+
// --- Core Settings ---
extern string InpSymbolName                = "XAUUSD";
extern int    InpMagicNumber               = 777555;
extern int    InpExecTF                    = PERIOD_M1;
extern int    InpContextTF_M5              = PERIOD_M5;
extern int    InpContextTF_M15             = PERIOD_M15;
//+------------------------------------------------------------------+
//| INPUTS — RISK PARAMETERS                                         |
//+------------------------------------------------------------------+
// --- Risk Parameters ---
extern double InpRiskPercent               = 0.5;
extern double InpMaxDailyDD                = 3.0;
extern double InpMaxWeeklyDD               = 6.0;
extern int    InpMaxConsecLosses           = 4;
extern int    InpMaxTradesPerSession       = 5;
extern double InpMaxSpreadPoints           = 50.0;
extern int    InpMaxSlippagePoints         = 30;
extern int    InpMaxRetries                = 3;
//+------------------------------------------------------------------+
//| INPUTS — INDICATOR PERIODS                                       |
//+------------------------------------------------------------------+
// --- Indicator Periods ---
extern int    InpATRPeriod                 = 14;
extern int    InpADXPeriod                 = 14;
extern int    InpRSIPeriod                 = 14;
extern int    InpEMAFast                   = 20;
extern int    InpEMASlow                   = 50;
extern int    InpBBPeriod                  = 20;
extern double InpBBDeviation              = 2.0;
//+------------------------------------------------------------------+
//| INPUTS — REGIME THRESHOLDS                                       |
//+------------------------------------------------------------------+
// --- Regime Thresholds ---
extern double InpADXTrendThreshold         = 25.0;
extern double InpADXWeakThreshold          = 18.0;
extern double InpBBWidthExpandThreshold    = 0.003;
extern double InpBBWidthCompressThreshold  = 0.0015;
extern double InpATRPercentileHigh         = 70.0;
extern int    InpADXSlopeBars              = 3;
//+------------------------------------------------------------------+
//| INPUTS — ENTRY PARAMETERS                                        |
//+------------------------------------------------------------------+
// --- Entry Parameters ---
extern double InpRSIOverbought             = 70.0;
extern double InpRSIOversold               = 30.0;
extern double InpMinSetupQuality           = 0.5;
extern double InpOverextensionATRMult      = 2.5;
extern double InpMinBodyRatio              = 0.4;
extern int    InpSessionStartHour          = 7;
extern int    InpSessionEndHour            = 20;
//+------------------------------------------------------------------+
//| INPUTS — POSITION MANAGEMENT                                     |
//+------------------------------------------------------------------+
// --- Position Management ---
extern double InpATRSLMultiplier           = 1.5;
extern double InpInitialTPMultR            = 2.0;
extern double InpBETriggerR                = 1.0;
extern double InpBEBufferPoints            = 10.0;
extern double InpPartial1Pct               = 30.0;
extern double InpPartial1TriggerR          = 1.0;
extern double InpPartial2Pct               = 30.0;
extern double InpPartial2TriggerR          = 2.0;
extern int    InpMinBarsBeforeBE           = 3;
//+------------------------------------------------------------------+
//| INPUTS — TRAILING                                                |
//+------------------------------------------------------------------+
// --- Trailing Parameters ---
extern double InpATRTrailMultiplier        = 2.0;
extern int    InpSwingLookback             = 10;
extern double InpFastBankTriggerR          = 0.5;
extern double InpFastBankTrailPoints       = 30.0;
//+------------------------------------------------------------------+
//| INPUTS — MDAE PARAMETERS                                         |
//+------------------------------------------------------------------+
// --- MDAE Parameters ---
extern int    InpSpeedWindowShort          = 5;
extern int    InpSpeedWindowLong           = 20;
extern int    InpVolumeAvgPeriod           = 20;
extern double InpVolumePulseThreshold      = 1.5;
extern int    InpTop2Lookback              = 20;
extern int    InpLowVolBoxPeriod           = 10;
extern double InpLowVolBoxThreshold        = 0.5;
extern double InpFibLevel1                 = 1.272;
extern double InpFibLevel2                 = 1.618;
extern int    InpMaxPolicySwitches         = 2;
extern int    InpMaxTradeAgeBars           = 120;
extern double InpEntropyHighThreshold      = 0.7;
extern double InpContinuationThreshold     = 0.6;
extern double InpExhaustionThreshold       = 0.4;
//+------------------------------------------------------------------+
//| INPUTS — NEWS WINDOW                                             |
//+------------------------------------------------------------------+
// --- News Window ---
extern int    InpNewsBlockStartHour        = 13;
extern int    InpNewsBlockStartMin         = 25;
extern int    InpNewsBlockEndHour          = 13;
extern int    InpNewsBlockEndMin           = 40;
//+------------------------------------------------------------------+
//| MANAGED STATE STRUCTURE                                          |
//+------------------------------------------------------------------+
// MT4 limitation: no struct support in older builds, using globals
int      g_msActive       = 0; // 0=false, 1=true
int      g_msTicket       = 0;
int      g_msDirection    = 0; // +1 buy, -1 sell
double   g_msEntryPrice   = 0;
double   g_msInitialSL    = 0;
double   g_msInitialTP    = 0;
double   g_msInitialVolume= 0;
double   g_msRiskDistance  = 0;
double   g_msMFE          = 0;
double   g_msMAE          = 0;
double   g_msCurrentR     = 0;
int      g_msBEApplied    = 0;
int      g_msPartial1Done = 0;
int      g_msPartial2Done = 0;
int      g_msActiveMethod = CM_FIXED;
int      g_msPolicySwitchCount = 0;
datetime g_msEntryTime    = 0;
int      g_msBarsInTrade  = 0;
double   g_msSpreadAtEntry= 0;
double   g_msSlippageAtEntry = 0;
int      g_msComplianceViolations = 0;
int      g_msStopDueSpread   = 0;
int      g_msStopDueSlippage = 0;
//+------------------------------------------------------------------+
//| GLOBAL STATE                                                     |
//+------------------------------------------------------------------+
datetime g_lastBar = 0;
double   g_startEquity = 0;
double   g_weekStartEquity = 0;
int      g_dailyLossCount = 0;
int      g_weeklyLossCount = 0;
int      g_dayStamp = 0;
int      g_weekStamp = 0;
int      g_sessionTradeCount = 0;
int      g_sessionDayStamp = 0;
int      g_logHandle = INVALID_HANDLE;
int      g_complianceTotalChecks = 0;
int      g_complianceTotalViolations = 0;
int      g_currentRegime = REGIME_NO_TRADE;
double   g_regimeConfidence = 0.0;
string   g_regimeRejectReason = "";
// For loss tracking (MT4 has no OnTradeTransaction)
int      g_lastKnownOrdersTotal = 0;
int      g_previousClosedCount = 0;
//+------------------------------------------------------------------+
//| INITIALIZATION                                                   |
//+------------------------------------------------------------------+
int init()
{
   if(!EnableEA)
   {
      Print("EA is disabled via EnableEA input.");
      return(INIT_SUCCEEDED);
   }
   g_startEquity = AccountEquity();
   g_weekStartEquity = g_startEquity;
   MqlDateTime dt;
   TimeCurrent(dt);
   g_dayStamp = dt.day_of_year;
   g_weekStamp = dt.day_of_year / 7;
   g_sessionDayStamp = g_dayStamp;
   ResetManagedState();
   ReconstructOpenPosition();
   if(EnableLogging)
   {
      string logName = InpSymbolName + "_MDAE_Log_" + IntegerToString(InpMagicNumber) + ".csv";
      g_logHandle = FileOpen(logName, FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
      if(g_logHandle != INVALID_HANDLE)
      {
         FileWrite(g_logHandle, "Timestamp","Symbol","TradeID","Event","Regime","Side",
                   "CurrentR","Method","Action","ReasonCode","Spread","Volume",
                   "Entropy","StopDueSpread","StopDueSlippage");
      }
   }
   g_previousClosedCount = CountClosedOrders();
   Print("XAUUSD Adaptive MDAE EA (MT4) initialized successfully.");
   return(INIT_SUCCEEDED);
}
//+------------------------------------------------------------------+
//| DEINITIALIZATION                                                 |
//+------------------------------------------------------------------+
int deinit()
{
   if(g_logHandle != INVALID_HANDLE)
   {
      FileClose(g_logHandle);
      g_logHandle = INVALID_HANDLE;
   }
   Print("XAUUSD Adaptive MDAE EA (MT4) deinitialized. Compliance violations: ", g_complianceTotalViolations);
   return(0);
}
//+------------------------------------------------------------------+
//| ONTICK                                                           |
//+------------------------------------------------------------------+
int start()
{
   if(!EnableEA) return(0);
   CheckDayWeekReset();
   CheckForClosedTrades(); // MT4 substitute for OnTradeTransaction
   // 1) Manage existing position first
   if(EnablePositionManagement && g_msActive == 1)
      ManagePosition();
   // 2) On new bar, evaluate entries
   if(NewBar())
   {
      if(EnableEntries && g_msActive == 0)
         EvaluateEntry();
   }
   return(0);
}
//+------------------------------------------------------------------+
//| HELPER — NewBar                                                  |
//+------------------------------------------------------------------+
bool NewBar()
{
   datetime t = iTime(InpSymbolName, InpExecTF, 0);
   if(t == 0) return(false);
   if(t != g_lastBar)
   {
      g_lastBar = t;
      return(true);
   }
   return(false);
}
//+------------------------------------------------------------------+
//| HELPER — NormalizePrice                                          |
//+------------------------------------------------------------------+
double NormPrice(double price)
{
   double tickSize = MarketInfo(InpSymbolName, MODE_TICKSIZE);
   if(tickSize <= 0) tickSize = MarketInfo(InpSymbolName, MODE_POINT);
   if(tickSize <= 0) return(NormalizeDouble(price, (int)MarketInfo(InpSymbolName, MODE_DIGITS)));
   return(NormalizeDouble(MathRound(price / tickSize) * tickSize, (int)MarketInfo(InpSymbolName, MODE_DIGITS)));
}
//+------------------------------------------------------------------+
//| HELPER — NormalizeLot                                            |
//+------------------------------------------------------------------+
double NormLot(double lots)
{
   double minLot  = MarketInfo(InpSymbolName, MODE_MINLOT);
   double maxLot  = MarketInfo(InpSymbolName, MODE_MAXLOT);
   double lotStep = MarketInfo(InpSymbolName, MODE_LOTSTEP);
   if(lotStep <= 0) lotStep = 0.01;
   lots = MathFloor(lots / lotStep) * lotStep;
   if(lots < minLot) lots = minLot;
   if(lots > maxLot) lots = maxLot;
   return(NormalizeDouble(lots, 2));
}
//+------------------------------------------------------------------+
//| HELPER — Current Spread                                          |
//+------------------------------------------------------------------+
double CurrentSpreadPoints()
{
   return((double)MarketInfo(InpSymbolName, MODE_SPREAD));
}
//+------------------------------------------------------------------+
//| HELPER — IsOurOrder (find our open order)                        |
//+------------------------------------------------------------------+
int FindOurTicket()
{
   for(int i = OrdersTotal()-1; i >= 0; i--)
   {
      if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) continue;
      if(OrderSymbol() != InpSymbolName) continue;
      if(OrderMagicNumber() != InpMagicNumber) continue;
      if(OrderType() == OP_BUY || OrderType() == OP_SELL)
         return(OrderTicket());
   }
   return(0);
}
bool IsOurPositionOpen()
{
   return(FindOurTicket() > 0);
}
//+------------------------------------------------------------------+
//| HELPER — Count closed orders (for loss tracking)                 |
//+------------------------------------------------------------------+
int CountClosedOrders()
{
   int count = 0;
   for(int i = OrdersHistoryTotal()-1; i >= 0; i--)
   {
      if(!OrderSelect(i, SELECT_BY_POS, MODE_HISTORY)) continue;
      if(OrderSymbol() != InpSymbolName) continue;
      if(OrderMagicNumber() != InpMagicNumber) continue;
      count++;
   }
   return(count);
}
//+------------------------------------------------------------------+
//| HELPER — Check for newly closed trades (MT4 OnTradeTransaction)  |
//+------------------------------------------------------------------+
void CheckForClosedTrades()
{
   int currentClosedCount = CountClosedOrders();
   if(currentClosedCount <= g_previousClosedCount) return;
   // Process new closed orders
   for(int i = OrdersHistoryTotal()-1; i >= 0; i--)
   {
      if(!OrderSelect(i, SELECT_BY_POS, MODE_HISTORY)) continue;
      if(OrderSymbol() != InpSymbolName) continue;
      if(OrderMagicNumber() != InpMagicNumber) continue;
      // Check if this is a full close of our managed position
      if(g_msActive == 1 && OrderTicket() == g_msTicket)
      {
         double profit = OrderProfit() + OrderSwap() + OrderCommission();
         if(profit < 0)
         {
            g_dailyLossCount++;
            g_weeklyLossCount++;
         }
         LogTradeSummary("CLOSED", profit);
         ResetManagedState();
         break;
      }
   }
   // Also check if our position still exists
   if(g_msActive == 1)
   {
      int ticket = FindOurTicket();
      if(ticket == 0)
      {
         // Position no longer exists
         LogTradeSummary("CLOSED_DETECTED", 0);
         ResetManagedState();
      }
   }
   g_previousClosedCount = currentClosedCount;
}
//+------------------------------------------------------------------+
//| HELPER — Day/Week Reset                                          |
//+------------------------------------------------------------------+
void CheckDayWeekReset()
{
   MqlDateTime dt;
   TimeCurrent(dt);
   int curDay = dt.day_of_year;
   int curWeek = curDay / 7;
   if(curDay != g_dayStamp)
   {
      g_dayStamp = curDay;
      g_startEquity = AccountEquity();
      g_dailyLossCount = 0;
   }
   if(curDay != g_sessionDayStamp)
   {
      g_sessionDayStamp = curDay;
      g_sessionTradeCount = 0;
   }
   if(curWeek != g_weekStamp)
   {
      g_weekStamp = curWeek;
      g_weekStartEquity = AccountEquity();
      g_weeklyLossCount = 0;
   }
}
//+------------------------------------------------------------------+
//| HELPER — Reset Managed State                                     |
//+------------------------------------------------------------------+
void ResetManagedState()
{
   g_msActive = 0;
   g_msTicket = 0;
   g_msDirection = 0;
   g_msEntryPrice = 0;
   g_msInitialSL = 0;
   g_msInitialTP = 0;
   g_msInitialVolume = 0;
   g_msRiskDistance = 0;
   g_msMFE = 0;
   g_msMAE = 0;
   g_msCurrentR = 0;
   g_msBEApplied = 0;
   g_msPartial1Done = 0;
   g_msPartial2Done = 0;
   g_msActiveMethod = CM_FIXED;
   g_msPolicySwitchCount = 0;
   g_msEntryTime = 0;
   g_msBarsInTrade = 0;
   g_msSpreadAtEntry = 0;
   g_msSlippageAtEntry = 0;
   g_msComplianceViolations = 0;
   g_msStopDueSpread = 0;
   g_msStopDueSlippage = 0;
}
//+------------------------------------------------------------------+
//| HELPER — Reconstruct Open Position on Restart                    |
//+------------------------------------------------------------------+
void ReconstructOpenPosition()
{
   int ticket = FindOurTicket();
   if(ticket == 0) return;
   if(!OrderSelect(ticket, SELECT_BY_TICKET)) return;
   g_msActive = 1;
   g_msTicket = ticket;
   g_msEntryPrice = OrderOpenPrice();
   g_msInitialSL = OrderStopLoss();
   g_msInitialTP = OrderTakeProfit();
   g_msInitialVolume = OrderLots();
   g_msEntryTime = OrderOpenTime();
   g_msDirection = (OrderType() == OP_BUY) ? 1 : -1;
   g_msRiskDistance = MathAbs(g_msEntryPrice - g_msInitialSL);
   if(g_msRiskDistance <= 0)
   {
      double atr = iATR(InpSymbolName, InpExecTF, InpATRPeriod, 1);
      g_msRiskDistance = (atr > 0) ? atr * InpATRSLMultiplier : 100 * MarketInfo(InpSymbolName, MODE_POINT);
   }
   g_msMFE = 0;
   g_msMAE = 0;
   g_msBEApplied = 0;
   g_msPartial1Done = 0;
   g_msPartial2Done = 0;
   g_msActiveMethod = CM_FIXED;
   g_msPolicySwitchCount = 0;
   g_msBarsInTrade = 0;
   g_msComplianceViolations = 0;
   g_msStopDueSpread = 0;
   g_msStopDueSlippage = 0;
   Print("INFO: Reconstructed open position ticket=", ticket, " dir=", g_msDirection, " entry=", g_msEntryPrice);
   LogDecisionEvent("RECONSTRUCTION", "Reconstructed existing position on restart", 0);
}
//+------------------------------------------------------------------+
//| HELPER — Session Filter                                          |
//+------------------------------------------------------------------+
bool IsWithinSession()
{
   if(!EnableSessionFilter) return(true);
   MqlDateTime dt;
   TimeCurrent(dt);
   return(dt.hour >= InpSessionStartHour && dt.hour < InpSessionEndHour);
}
//+------------------------------------------------------------------+
//| HELPER — News Window Block                                       |
//+------------------------------------------------------------------+
bool IsNewsBlocked()
{
   if(!EnableNewsWindowBlock) return(false);
   MqlDateTime dt;
   TimeCurrent(dt);
   int nowMin = dt.hour * 60 + dt.min;
   int startMin = InpNewsBlockStartHour * 60 + InpNewsBlockStartMin;
   int endMin   = InpNewsBlockEndHour * 60 + InpNewsBlockEndMin;
   return(nowMin >= startMin && nowMin <= endMin);
}
//+------------------------------------------------------------------+
//| RISK GOVERNOR — RiskCheck                                        |
//+------------------------------------------------------------------+
int RiskCheck()
{
   if(!EnableRiskGovernor) return(RISK_ALLOW);
   double equity = AccountEquity();
   if(EnableDailyDDLock && g_startEquity > 0)
   {
      double ddPct = ((g_startEquity - equity) / g_startEquity) * 100.0;
      if(ddPct >= InpMaxDailyDD)
      {
         LogDecisionEvent("RISK_GOVERNOR", "Daily DD lock: " + DoubleToString(ddPct,2) + "%", 0);
         return(RISK_BLOCK);
      }
   }
   if(EnableWeeklyDDLock && g_weekStartEquity > 0)
   {
      double wddPct = ((g_weekStartEquity - equity) / g_weekStartEquity) * 100.0;
      if(wddPct >= InpMaxWeeklyDD)
      {
         LogDecisionEvent("RISK_GOVERNOR", "Weekly DD lock: " + DoubleToString(wddPct,2) + "%", 0);
         return(RISK_BLOCK);
      }
   }
   if(EnableConsecutiveLossLock && g_dailyLossCount >= InpMaxConsecLosses)
   {
      LogDecisionEvent("RISK_GOVERNOR", "Consecutive loss lock: " + IntegerToString(g_dailyLossCount), 0);
      return(RISK_BLOCK);
   }
   if(EnableMaxTradesPerSession && g_sessionTradeCount >= InpMaxTradesPerSession)
   {
      LogDecisionEvent("RISK_GOVERNOR", "Max session trades reached", 0);
      return(RISK_BLOCK);
   }
   if(EnableDailyDDLock && g_startEquity > 0)
   {
      double ddPct = ((g_startEquity - equity) / g_startEquity) * 100.0;
      if(ddPct >= InpMaxDailyDD * 0.7)
         return(RISK_REDUCE);
   }
   return(RISK_ALLOW);
}
bool IsTradingLocked()
{
   return(RiskCheck() == RISK_BLOCK);
}
//+------------------------------------------------------------------+
//| RISK GOVERNOR — CalcLotSizeByRisk                                |
//+------------------------------------------------------------------+
double CalcLotSizeByRisk(double slDistancePrice)
{
   if(slDistancePrice <= 0) return(MarketInfo(InpSymbolName, MODE_MINLOT));
   double equity = AccountEquity();
   double riskPct = InpRiskPercent;
   int rs = RiskCheck();
   if(rs == RISK_REDUCE) riskPct *= 0.5;
   double riskMoney = equity * riskPct / 100.0;
   double tickValue = MarketInfo(InpSymbolName, MODE_TICKVALUE);
   double tickSize  = MarketInfo(InpSymbolName, MODE_TICKSIZE);
   if(tickValue <= 0 || tickSize <= 0) return(MarketInfo(InpSymbolName, MODE_MINLOT));
   double slTicks = slDistancePrice / tickSize;
   double lossPerLot = slTicks * tickValue;
   if(lossPerLot <= 0) return(MarketInfo(InpSymbolName, MODE_MINLOT));
   double lots = riskMoney / lossPerLot;
   return(NormLot(lots));
}
//+------------------------------------------------------------------+
//| REGIME ENGINE — DetectRegime                                     |
//+------------------------------------------------------------------+
int DetectRegime()
{
   if(!EnableRegimeEngine) return(REGIME_TREND_EXPANSION);
   double adxVal  = iADX(InpSymbolName, InpExecTF, InpADXPeriod, PRICE_CLOSE, MODE_MAIN, 0);
   double adxPrev = iADX(InpSymbolName, InpExecTF, InpADXPeriod, PRICE_CLOSE, MODE_MAIN, InpADXSlopeBars);
   double bbUpper  = iBands(InpSymbolName, InpExecTF, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_UPPER, 0);
   double bbLower  = iBands(InpSymbolName, InpExecTF, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_LOWER, 0);
   double bbMiddle = iBands(InpSymbolName, InpExecTF, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_MAIN, 0);
   if(adxVal <= 0 || bbMiddle <= 0)
   {
      g_regimeRejectReason = "INDICATOR_FAIL";
      return(REGIME_NO_TRADE);
   }
   double bbWidth = (bbUpper - bbLower) / bbMiddle;
   double adxSlope = adxVal - adxPrev;
   bool trendSignal = (adxVal >= InpADXTrendThreshold && adxSlope > 0 && bbWidth >= InpBBWidthExpandThreshold);
   bool rangeSignal = (adxVal <= InpADXWeakThreshold && bbWidth <= InpBBWidthCompressThreshold);
   g_regimeConfidence = 0.0;
   if(trendSignal)
   {
      g_regimeConfidence = MathMin(1.0, (adxVal / 50.0) * (bbWidth / InpBBWidthExpandThreshold));
      g_regimeRejectReason = "";
      g_currentRegime = REGIME_TREND_EXPANSION;
      LogDecisionEvent("REGIME", "TREND_EXPANSION ADX=" + DoubleToString(adxVal,1) + " BBW=" + DoubleToString(bbWidth,5), g_regimeConfidence);
      return(REGIME_TREND_EXPANSION);
   }
   else if(rangeSignal)
   {
      g_regimeConfidence = MathMin(1.0, (1.0 - adxVal / InpADXTrendThreshold) * (1.0 - bbWidth / InpBBWidthExpandThreshold));
      g_regimeRejectReason = "";
      g_currentRegime = REGIME_MEAN_REVERSION;
      LogDecisionEvent("REGIME", "MEAN_REVERSION ADX=" + DoubleToString(adxVal,1) + " BBW=" + DoubleToString(bbWidth,5), g_regimeConfidence);
      return(REGIME_MEAN_REVERSION);
   }
   else
   {
      if(!EnableNoTradeState)
      {
         g_currentRegime = REGIME_TREND_EXPANSION;
         return(REGIME_TREND_EXPANSION);
      }
      g_regimeRejectReason = "UNCERTAIN";
      g_currentRegime = REGIME_NO_TRADE;
      LogDecisionEvent("REGIME", "NO_TRADE ADX=" + DoubleToString(adxVal,1) + " BBW=" + DoubleToString(bbWidth,5), 0);
      return(REGIME_NO_TRADE);
   }
}
//+------------------------------------------------------------------+
//| MTF CONTEXT CHECK                                                |
//+------------------------------------------------------------------+
int GetMTFDirection()
{
   if(!EnableMTFContextCheck) return(0);
   double emaFast5  = iMA(InpSymbolName, InpContextTF_M5, InpEMAFast, 0, MODE_EMA, PRICE_CLOSE, 0);
   double emaSlow5  = iMA(InpSymbolName, InpContextTF_M5, InpEMASlow, 0, MODE_EMA, PRICE_CLOSE, 0);
   double emaFast15 = iMA(InpSymbolName, InpContextTF_M15, InpEMAFast, 0, MODE_EMA, PRICE_CLOSE, 0);
   double emaSlow15 = iMA(InpSymbolName, InpContextTF_M15, InpEMASlow, 0, MODE_EMA, PRICE_CLOSE, 0);
   int dir5 = (emaFast5 > emaSlow5) ? 1 : -1;
   int dir15 = (emaFast15 > emaSlow15) ? 1 : -1;
   if(dir5 == dir15) return(dir5);
   return(0);
}
//+------------------------------------------------------------------+
//| SETUP ENGINE — EvaluateTrendEntry                                |
//+------------------------------------------------------------------+
int EvaluateTrendEntry(double &quality)
{
   quality = 0;
   if(!EnableTrendModule) return(0);
   double emaFast = iMA(InpSymbolName, InpExecTF, InpEMAFast, 0, MODE_EMA, PRICE_CLOSE, 0);
   double emaSlow = iMA(InpSymbolName, InpExecTF, InpEMASlow, 0, MODE_EMA, PRICE_CLOSE, 0);
   double rsi     = iRSI(InpSymbolName, InpExecTF, InpRSIPeriod, PRICE_CLOSE, 0);
   double atr     = iATR(InpSymbolName, InpExecTF, InpATRPeriod, 0);
   double close0 = iClose(InpSymbolName, InpExecTF, 0);
   double close1 = iClose(InpSymbolName, InpExecTF, 1);
   double close2 = iClose(InpSymbolName, InpExecTF, 2);
   double open0  = iOpen(InpSymbolName, InpExecTF, 0);
   if(close0 <= 0 || close1 <= 0 || atr <= 0) return(0);
   double distFromEMA = MathAbs(close0 - emaFast);
   if(distFromEMA > InpOverextensionATRMult * atr) return(0);
   double bodySize = MathAbs(close0 - open0);
   double candleRange = iHigh(InpSymbolName, InpExecTF, 0) - iLow(InpSymbolName, InpExecTF, 0);
   if(candleRange > 0 && (bodySize / candleRange) < InpMinBodyRatio) return(0);
   int mtfDir = GetMTFDirection();
   // BUY
   if(emaFast > emaSlow && close0 > emaFast && rsi > 40 && rsi < InpRSIOverbought)
   {
      bool pullback = (close1 <= emaFast * 1.001 || close2 <= emaFast * 1.001);
      if(!pullback) pullback = (iLow(InpSymbolName, InpExecTF, 1) <= emaFast);
      if(pullback)
      {
         if(mtfDir != 0 && mtfDir != 1) return(0);
         quality = 0.5 + (rsi - 40) / 60.0 * 0.3 + g_regimeConfidence * 0.2;
         quality = MathMin(1.0, quality);
         LogDecisionEvent("ENTRY_EVAL", "TREND_BUY quality=" + DoubleToString(quality,2), quality);
         return(1);
      }
   }
   // SELL
   if(emaFast < emaSlow && close0 < emaFast && rsi < 60 && rsi > InpRSIOversold)
   {
      bool pullback = (close1 >= emaFast * 0.999 || close2 >= emaFast * 0.999);
      if(!pullback) pullback = (iHigh(InpSymbolName, InpExecTF, 1) >= emaFast);
      if(pullback)
      {
         if(mtfDir != 0 && mtfDir != -1) return(0);
         quality = 0.5 + (60 - rsi) / 60.0 * 0.3 + g_regimeConfidence * 0.2;
         quality = MathMin(1.0, quality);
         LogDecisionEvent("ENTRY_EVAL", "TREND_SELL quality=" + DoubleToString(quality,2), quality);
         return(-1);
      }
   }
   return(0);
}
//+------------------------------------------------------------------+
//| SETUP ENGINE — EvaluateMeanReversionEntry                        |
//+------------------------------------------------------------------+
int EvaluateMeanReversionEntry(double &quality)
{
   quality = 0;
   if(!EnableMeanReversionModule) return(0);
   double bbUpper  = iBands(InpSymbolName, InpExecTF, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_UPPER, 0);
   double bbLower  = iBands(InpSymbolName, InpExecTF, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_LOWER, 0);
   double bbMiddle = iBands(InpSymbolName, InpExecTF, InpBBPeriod, InpBBDeviation, 0, PRICE_CLOSE, MODE_MAIN, 0);
   double rsi      = iRSI(InpSymbolName, InpExecTF, InpRSIPeriod, PRICE_CLOSE, 0);
   double atr      = iATR(InpSymbolName, InpExecTF, InpATRPeriod, 0);
   double adxVal   = iADX(InpSymbolName, InpExecTF, InpADXPeriod, PRICE_CLOSE, MODE_MAIN, 0);
   double close0 = iClose(InpSymbolName, InpExecTF, 0);
   double open0  = iOpen(InpSymbolName, InpExecTF, 0);
   double low0   = iLow(InpSymbolName, InpExecTF, 0);
   double high0  = iHigh(InpSymbolName, InpExecTF, 0);
   if(close0 <= 0 || atr <= 0) return(0);
   double adxPrev = iADX(InpSymbolName, InpExecTF, InpADXPeriod, PRICE_CLOSE, MODE_MAIN, 3);
   if(adxVal - adxPrev > 5.0) return(0);
   double candleRange = high0 - low0;
   int mtfDir = GetMTFDirection();
   // BUY
   if(low0 <= bbLower && close0 > bbLower && rsi < InpRSIOversold + 10)
   {
      double clv = (candleRange > 0) ? (close0 - low0) / candleRange : 0.5;
      if(clv < 0.4) return(0);
      if(mtfDir != 0 && mtfDir != 1) return(0);
      quality = 0.5 + (InpRSIOversold + 10 - rsi) / 40.0 * 0.3 + clv * 0.2;
      quality = MathMin(1.0, quality);
      LogDecisionEvent("ENTRY_EVAL", "MR_BUY quality=" + DoubleToString(quality,2), quality);
      return(1);
   }
   // SELL
   if(high0 >= bbUpper && close0 < bbUpper && rsi > InpRSIOverbought - 10)
   {
      double clv = (candleRange > 0) ? (high0 - close0) / candleRange : 0.5;
      if(clv < 0.4) return(0);
      if(mtfDir != 0 && mtfDir != -1) return(0);
      quality = 0.5 + (rsi - (InpRSIOverbought - 10)) / 40.0 * 0.3 + clv * 0.2;
      quality = MathMin(1.0, quality);
      LogDecisionEvent("ENTRY_EVAL", "MR_SELL quality=" + DoubleToString(quality,2), quality);
      return(-1);
   }
   return(0);
}
//+------------------------------------------------------------------+
//| ENTRY EVALUATION — Main                                          |
//+------------------------------------------------------------------+
void EvaluateEntry()
{
   if(IsTradingLocked())
   {
      LogDecisionEvent("PRECHECK", "Trading locked by RiskGovernor", 0);
      return;
   }
   if(!IsWithinSession()) return;
   if(IsNewsBlocked())
   {
      LogDecisionEvent("PRECHECK", "News window block active", 0);
      return;
   }
   if(EnableSpreadEntryFilter)
   {
      double spread = CurrentSpreadPoints();
      if(spread > InpMaxSpreadPoints)
      {
         LogDecisionEvent("PRECHECK", "Spread too high: " + DoubleToString(spread,1), 0);
         return;
      }
   }
   if(EnableOnePositionOnly && IsOurPositionOpen()) return;
   int regime = DetectRegime();
   if(regime == REGIME_NO_TRADE) return;
   double quality = 0;
   int side = 0;
   if(regime == REGIME_TREND_EXPANSION)
      side = EvaluateTrendEntry(quality);
   else if(regime == REGIME_MEAN_REVERSION)
      side = EvaluateMeanReversionEntry(quality);
   if(side == 0) return;
   if(quality < InpMinSetupQuality)
   {
      LogDecisionEvent("ENTRY_DECISION", "Rejected: quality " + DoubleToString(quality,2) + " < threshold", quality);
      return;
   }
   OpenTrade(side, regime);
}
//+------------------------------------------------------------------+
//| OPEN TRADE                                                       |
//+------------------------------------------------------------------+
void OpenTrade(int side, int regime)
{
   double atr = iATR(InpSymbolName, InpExecTF, InpATRPeriod, 1);
   if(atr <= 0)
   {
      LogDecisionEvent("ORDER_SUBMIT", "ATR read fail", 0);
      return;
   }
   double ask = MarketInfo(InpSymbolName, MODE_ASK);
   double bid = MarketInfo(InpSymbolName, MODE_BID);
   if(ask <= 0 || bid <= 0) return;
   double slDist = atr * InpATRSLMultiplier;
   double tpDist = slDist * InpInitialTPMultR;
   double entryPrice, sl, tp;
   int orderType;
   if(side == 1)
   {
      entryPrice = ask;
      sl = NormPrice(entryPrice - slDist);
      tp = NormPrice(entryPrice + tpDist);
      orderType = OP_BUY;
   }
   else
   {
      entryPrice = bid;
      sl = NormPrice(entryPrice + slDist);
      tp = NormPrice(entryPrice - tpDist);
      orderType = OP_SELL;
   }
   // Validate stop distance
   int stopsLevel = (int)MarketInfo(InpSymbolName, MODE_STOPLEVEL);
   double minStopDist = stopsLevel * MarketInfo(InpSymbolName, MODE_POINT);
   if(slDist < minStopDist)
   {
      slDist = minStopDist * 1.1;
      if(side == 1) sl = NormPrice(entryPrice - slDist);
      else          sl = NormPrice(entryPrice + slDist);
   }
   double lots = CalcLotSizeByRisk(slDist);
   // Margin check
   double marginRequired = lots * MarketInfo(InpSymbolName, MODE_MARGINREQUIRED);
   if(marginRequired > AccountFreeMargin() * 0.9)
   {
      LogDecisionEvent("ORDER_SUBMIT", "Insufficient margin", 0);
      return;
   }
   double spreadAtEntry = CurrentSpreadPoints();
   string comment = "MDAE";
   if(regime == REGIME_TREND_EXPANSION) comment = "MDAE_TREND";
   else if(regime == REGIME_MEAN_REVERSION) comment = "MDAE_MR";
   int ticket = -1;
   for(int retry = 0; retry < InpMaxRetries; retry++)
   {
      RefreshRates();
      double price = (side == 1) ? MarketInfo(InpSymbolName, MODE_ASK) : MarketInfo(InpSymbolName, MODE_BID);
      ticket = OrderSend(InpSymbolName, orderType, lots, price, InpMaxSlippagePoints, sl, tp, comment, InpMagicNumber, 0, (side==1) ? clrGreen : clrRed);
      if(ticket > 0) break;
      int err = GetLastError();
      if(EnableDebugPrints) Print("DEBUG: OrderSend retry ", retry, " err=", err);
      if(err == ERR_REQUOTE || err == ERR_PRICE_CHANGED || err == ERR_OFF_QUOTES)
         Sleep(200);
      else
         break;
   }
   if(ticket > 0)
   {
      if(OrderSelect(ticket, SELECT_BY_TICKET))
      {
         g_msActive = 1;
         g_msTicket = ticket;
         g_msDirection = side;
         g_msEntryPrice = OrderOpenPrice();
         g_msInitialSL = sl;
         g_msInitialTP = tp;
         g_msInitialVolume = lots;
         g_msRiskDistance = slDist;
         g_msMFE = 0;
         g_msMAE = 0;
         g_msCurrentR = 0;
         g_msBEApplied = 0;
         g_msPartial1Done = 0;
         g_msPartial2Done = 0;
         g_msActiveMethod = (regime == REGIME_MEAN_REVERSION) ? CM_FIXED : CM_ATR;
         g_msPolicySwitchCount = 0;
         g_msEntryTime = TimeCurrent();
         g_msBarsInTrade = 0;
         g_msSpreadAtEntry = spreadAtEntry;
         g_msSlippageAtEntry = 0;
         g_msComplianceViolations = 0;
         g_msStopDueSpread = 0;
         g_msStopDueSlippage = 0;
         g_sessionTradeCount++;
         LogDecisionEvent("ORDER_SUBMIT", "Opened " + ((side==1)?"BUY":"SELL") +
            " lots=" + DoubleToString(lots,2) +
            " SL=" + DoubleToString(sl, (int)MarketInfo(InpSymbolName, MODE_DIGITS)) +
            " TP=" + DoubleToString(tp, (int)MarketInfo(InpSymbolName, MODE_DIGITS)) +
            " spread=" + DoubleToString(spreadAtEntry,1), 0);
      }
   }
   else
   {
      LogDecisionEvent("ORDER_SUBMIT", "FAILED err=" + IntegerToString(GetLastError()), 0);
   }
}
//+------------------------------------------------------------------+
//| MDAE FEATURES                                                    |
//+------------------------------------------------------------------+
// Using parallel arrays instead of struct for MT4 compat
double g_featSpeedNow = 0;
double g_featSpeedShort = 0;
double g_featSpeedLong = 0;
double g_featAcceleration = 0;
double g_featVolumePulse = 0;
double g_featBodyExpansion = 0;
int    g_featTop2Breakout = 0;
int    g_featInLowVolBox = 0;
double g_featFibProximity = 0;
double g_featEntropyScore = 0;
double g_featContinuationScore = 0;
void ComputeMDAEFeatures()
{
   g_featSpeedNow = 0; g_featSpeedShort = 0; g_featSpeedLong = 0;
   g_featAcceleration = 0; g_featVolumePulse = 0; g_featBodyExpansion = 0;
   g_featTop2Breakout = 0; g_featInLowVolBox = 0; g_featFibProximity = 0;
   g_featEntropyScore = 0; g_featContinuationScore = 0;
   double close0 = iClose(InpSymbolName, InpExecTF, 0);
   if(close0 <= 0) return;
   // Speed
   if(EnablePipsPerSecond)
   {
      double close1 = iClose(InpSymbolName, InpExecTF, 1);
      datetime time0 = iTime(InpSymbolName, InpExecTF, 0);
      datetime time1 = iTime(InpSymbolName, InpExecTF, 1);
      double dtSec = (double)(time0 - time1);
      if(dtSec > 0) g_featSpeedNow = MathAbs(close0 - close1) / dtSec;
      double closeS = iClose(InpSymbolName, InpExecTF, InpSpeedWindowShort);
      datetime timeS = iTime(InpSymbolName, InpExecTF, InpSpeedWindowShort);
      double dtS = (double)(time0 - timeS);
      if(dtS > 0) g_featSpeedShort = MathAbs(close0 - closeS) / dtS;
      double closeL = iClose(InpSymbolName, InpExecTF, InpSpeedWindowLong);
      datetime timeL = iTime(InpSymbolName, InpExecTF, InpSpeedWindowLong);
      double dtL = (double)(time0 - timeL);
      if(dtL > 0) g_featSpeedLong = MathAbs(close0 - closeL) / dtL;
      g_featAcceleration = (g_featSpeedLong > 0) ? g_featSpeedShort / g_featSpeedLong : 1.0;
   }
   // Volume pulse
   if(EnableVolumePulse)
   {
      double vol0 = (double)iVolume(InpSymbolName, InpExecTF, 0);
      double volAvg = 0;
      for(int i = 1; i <= InpVolumeAvgPeriod; i++)
         volAvg += (double)iVolume(InpSymbolName, InpExecTF, i);
      volAvg /= InpVolumeAvgPeriod;
      g_featVolumePulse = (volAvg > 0) ? vol0 / volAvg : 1.0;
   }
   // Body expansion
   if(EnableBodyExpansion)
   {
      double body0 = MathAbs(iClose(InpSymbolName, InpExecTF, 0) - iOpen(InpSymbolName, InpExecTF, 0));
      double body1 = MathAbs(iClose(InpSymbolName, InpExecTF, 1) - iOpen(InpSymbolName, InpExecTF, 1));
      g_featBodyExpansion = (body1 > 0) ? body0 / body1 : 1.0;
   }
   // Top-2 breakout
   if(EnableTop2BreakoutCheck)
   {
      double highest = close0, secondHighest = close0;
      double lowest = close0, secondLowest = close0;
      for(int i = 1; i <= InpTop2Lookback; i++)
      {
         double h = iHigh(InpSymbolName, InpExecTF, i);
         double l = iLow(InpSymbolName, InpExecTF, i);
         if(h > highest) { secondHighest = highest; highest = h; }
         else if(h > secondHighest) secondHighest = h;
         if(l < lowest) { secondLowest = lowest; lowest = l; }
         else if(l < secondLowest) secondLowest = l;
      }
      if(g_msDirection == 1) g_featTop2Breakout = (close0 > secondHighest) ? 1 : 0;
      else                   g_featTop2Breakout = (close0 < secondLowest) ? 1 : 0;
   }
   // Low volume box
   if(EnableLowVolumeBox)
   {
      double volAvg = 0;
      for(int i = 0; i < InpLowVolBoxPeriod; i++)
         volAvg += (double)iVolume(InpSymbolName, InpExecTF, i);
      volAvg /= InpLowVolBoxPeriod;
      double longVolAvg = 0;
      for(int i = 0; i < InpVolumeAvgPeriod; i++)
         longVolAvg += (double)iVolume(InpSymbolName, InpExecTF, i);
      longVolAvg /= InpVolumeAvgPeriod;
      g_featInLowVolBox = (longVolAvg > 0 && volAvg / longVolAvg < InpLowVolBoxThreshold) ? 1 : 0;
   }
   // Fib guidance
   if(EnableFibGuidance && g_msActive == 1 && g_msRiskDistance > 0)
   {
      double progress = g_msCurrentR;
      g_featFibProximity = 0;
      if(MathAbs(progress - InpFibLevel1) < 0.1) g_featFibProximity = 0.7;
      if(MathAbs(progress - InpFibLevel2) < 0.1) g_featFibProximity = 1.0;
   }
   // Entropy scoring
   if(EnableEntropyScoring)
   {
      double speedSignal = (g_featAcceleration > 1.2) ? 1.0 : (g_featAcceleration < 0.8) ? -1.0 : 0.0;
      double volSignal   = (g_featVolumePulse > InpVolumePulseThreshold) ? 1.0 : (g_featVolumePulse < 0.7) ? -1.0 : 0.0;
      double structSignal = (g_featTop2Breakout == 1) ? 1.0 : 0.0;
      double boxSignal   = (g_featInLowVolBox == 1) ? -1.0 : 0.0;
      double sum = speedSignal + volSignal + structSignal + boxSignal;
      double agreement = MathAbs(sum) / 4.0;
      g_featEntropyScore = 1.0 - agreement;
      g_featContinuationScore = ((sum > 0 && g_msDirection == 1) || (sum < 0 && g_msDirection == -1)) ?
                                agreement : (1.0 - agreement) * 0.3;
   }
}
//+------------------------------------------------------------------+
//| MDAE — SelectCloseMethod                                         |
//+------------------------------------------------------------------+
int SelectCloseMethod()
{
   if(!EnableMDAE) return(CM_FIXED);
   if(g_featEntropyScore > InpEntropyHighThreshold && g_featContinuationScore < InpExhaustionThreshold)
      return(CM_EXIT);
   if(EnableFastBankMode && g_featInLowVolBox == 1 && g_msCurrentR > InpFastBankTriggerR)
      return(CM_FAST);
   if(g_featContinuationScore > InpContinuationThreshold)
   {
      if(EnableSwingTrail && g_featTop2Breakout == 1 && g_featVolumePulse > InpVolumePulseThreshold)
         return(CM_SWING);
      if(EnableATRTrail)
         return(CM_ATR);
   }
   if(EnableHybridCloseMode && g_featEntropyScore > 0.4 && g_featEntropyScore <= InpEntropyHighThreshold)
      return(CM_HYBRID);
   return(CM_FIXED);
}
//+------------------------------------------------------------------+
//| COMPLIANCE — Check Stop Policy                                   |
//+------------------------------------------------------------------+
bool ComplianceCheckStopPolicy(double newSL, string reason)
{
   if(!EnableComplianceAuditCounters) return(true);
   g_complianceTotalChecks++;
   bool violation = false;
   if(EnforceNoSpreadSlStopMoves && StringFind(reason, "SPREAD_TRIGGER") >= 0)
   {
      violation = true;
      g_msStopDueSpread = 1;
      LogDecisionEvent("COMPLIANCE", "VIOLATION: Stop due spread: " + reason, 0);
   }
   if(EnforceNoSlippageStopMoves && StringFind(reason, "SLIPPAGE_TRIGGER") >= 0)
   {
      violation = true;
      g_msStopDueSlippage = 1;
      LogDecisionEvent("COMPLIANCE", "VIOLATION: Stop due slippage: " + reason, 0);
   }
   if(violation)
   {
      g_complianceTotalViolations++;
      g_msComplianceViolations++;
      return(false);
   }
   return(true);
}
//+------------------------------------------------------------------+
//| POSITION MANAGEMENT — MoveSL                                     |
//+------------------------------------------------------------------+
bool MoveSL(double newSL, string reason)
{
   if(g_msActive == 0) return(false);
   if(!OrderSelect(g_msTicket, SELECT_BY_TICKET)) return(false);
   if(!ComplianceCheckStopPolicy(newSL, reason))
   {
      if(EnableDebugPrints) Print("DEBUG: SL move BLOCKED by compliance: ", reason);
      return(false);
   }
   double currentSL = OrderStopLoss();
   double currentTP = OrderTakeProfit();
   newSL = NormPrice(newSL);
   // Don't move SL worse
   if(g_msDirection == 1 && newSL <= currentSL && currentSL > 0) return(false);
   if(g_msDirection == -1 && newSL >= currentSL && currentSL > 0) return(false);
   // Validate stop distance
   double ask = MarketInfo(InpSymbolName, MODE_ASK);
   double bid = MarketInfo(InpSymbolName, MODE_BID);
   int stopsLevel = (int)MarketInfo(InpSymbolName, MODE_STOPLEVEL);
   int freezeLevel = (int)MarketInfo(InpSymbolName, MODE_FREEZELEVEL);
   double point = MarketInfo(InpSymbolName, MODE_POINT);
   double minDist = MathMax((double)stopsLevel, (double)freezeLevel) * point;
   if(g_msDirection == 1 && bid - newSL < minDist) return(false);
   if(g_msDirection == -1 && newSL - ask < minDist) return(false);
   bool result = OrderModify(g_msTicket, OrderOpenPrice(), newSL, currentTP, 0, clrBlue);
   if(result)
   {
      LogDecisionEvent("MANAGEMENT", "SL moved to " + DoubleToString(newSL, (int)MarketInfo(InpSymbolName, MODE_DIGITS)) + " reason=" + reason, g_msCurrentR);
      return(true);
   }
   else
   {
      if(EnableDebugPrints) Print("DEBUG: OrderModify failed, err=", GetLastError());
      return(false);
   }
}
//+------------------------------------------------------------------+
//| POSITION MANAGEMENT — PartialClose                               |
//+------------------------------------------------------------------+
bool PartialClosePercent(double pctOfOriginal, string reason)
{
   if(!EnablePartialClose) return(false);
   if(g_msActive == 0) return(false);
   if(!OrderSelect(g_msTicket, SELECT_BY_TICKET)) return(false);
   double currentVol = OrderLots();
   double closeVol = g_msInitialVolume * pctOfOriginal / 100.0;
   closeVol = NormLot(closeVol);
   double minLot = MarketInfo(InpSymbolName, MODE_MINLOT);
   if(closeVol < minLot)
   {
      LogDecisionEvent("MANAGEMENT", "Partial skip: vol " + DoubleToString(closeVol,2) + " < minLot", g_msCurrentR);
      return(false);
   }
   if(closeVol > currentVol) closeVol = currentVol;
   double remainder = NormLot(currentVol - closeVol);
   if(remainder > 0 && remainder < minLot)
      closeVol = currentVol;
   RefreshRates();
   double closePrice;
   if(g_msDirection == 1) closePrice = MarketInfo(InpSymbolName, MODE_BID);
   else                   closePrice = MarketInfo(InpSymbolName, MODE_ASK);
   bool result = OrderClose(g_msTicket, closeVol, closePrice, InpMaxSlippagePoints, clrYellow);
   if(result)
   {
      LogDecisionEvent("MANAGEMENT", "Partial " + DoubleToString(pctOfOriginal,0) + "% vol=" + DoubleToString(closeVol,2) + " reason=" + reason, g_msCurrentR);
      // After partial close in MT4, the remaining position may get a new ticket
      int newTicket = FindOurTicket();
      if(newTicket > 0 && newTicket != g_msTicket)
      {
         g_msTicket = newTicket;
         if(EnableDebugPrints) Print("DEBUG: Ticket updated after partial to ", newTicket);
      }
      else if(newTicket == 0)
      {
         // Fully closed
         ResetManagedState();
      }
   }
   return(result);
}
//+------------------------------------------------------------------+
//| POSITION MANAGEMENT — ApplyBreakEven                             |
//+------------------------------------------------------------------+
void ApplyBreakEven()
{
   if(!EnableBreakEven) return;
   if(g_msBEApplied == 1) return;
   if(g_msBarsInTrade < InpMinBarsBeforeBE) return;
   if(g_msCurrentR >= InpBETriggerR)
   {
      double bePrice;
      double point = MarketInfo(InpSymbolName, MODE_POINT);
      if(g_msDirection == 1) bePrice = g_msEntryPrice + InpBEBufferPoints * point;
      else                   bePrice = g_msEntryPrice - InpBEBufferPoints * point;
      if(MoveSL(bePrice, "BREAK_EVEN"))
      {
         g_msBEApplied = 1;
         LogDecisionEvent("MANAGEMENT", "Break-even at " + DoubleToString(g_msCurrentR,2) + "R", g_msCurrentR);
      }
   }
}
//+------------------------------------------------------------------+
//| POSITION MANAGEMENT — ApplyPartialClose                          |
//+------------------------------------------------------------------+
void ApplyPartialClose()
{
   if(!EnablePartialClose) return;
   if(g_msPartial1Done == 0 && g_msCurrentR >= InpPartial1TriggerR)
   {
      if(PartialClosePercent(InpPartial1Pct, "TP1_HIT"))
         g_msPartial1Done = 1;
   }
   if(g_msPartial2Done == 0 && g_msCurrentR >= InpPartial2TriggerR)
   {
      if(PartialClosePercent(InpPartial2Pct, "TP2_HIT"))
         g_msPartial2Done = 1;
   }
}
//+------------------------------------------------------------------+
//| POSITION MANAGEMENT — ApplyTrailingLogic                         |
//+------------------------------------------------------------------+
void ApplyTrailingLogic()
{
   double atr = iATR(InpSymbolName, InpExecTF, InpATRPeriod, 0);
   if(atr <= 0) return;
   double ask = MarketInfo(InpSymbolName, MODE_ASK);
   double bid = MarketInfo(InpSymbolName, MODE_BID);
   double currentPrice = (g_msDirection == 1) ? bid : ask;
   double point = MarketInfo(InpSymbolName, MODE_POINT);
   int method = g_msActiveMethod;
   // ATR Trail
   if(method == CM_ATR && EnableATRTrail)
   {
      double trailSL;
      if(g_msDirection == 1) trailSL = currentPrice - atr * InpATRTrailMultiplier;
      else                   trailSL = currentPrice + atr * InpATRTrailMultiplier;
      MoveSL(trailSL, "ATR_TRAIL");
   }
   // Swing Trail
   if(method == CM_SWING && EnableSwingTrail)
   {
      if(g_msDirection == 1)
      {
         double recentSwingLow = iLow(InpSymbolName, InpExecTF, 1);
         for(int i = 2; i <= MathMin(InpSwingLookback, 5); i++)
         {
            double lo = iLow(InpSymbolName, InpExecTF, i);
            if(lo > recentSwingLow) recentSwingLow = lo;
         }
         MoveSL(recentSwingLow - atr * 0.2, "SWING_TRAIL");
      }
      else
      {
         double recentSwingHigh = iHigh(InpSymbolName, InpExecTF, 1);
         for(int i = 2; i <= MathMin(InpSwingLookback, 5); i++)
         {
            double hi = iHigh(InpSymbolName, InpExecTF, i);
            if(hi < recentSwingHigh) recentSwingHigh = hi;
         }
         MoveSL(recentSwingHigh + atr * 0.2, "SWING_TRAIL");
      }
   }
   // Fast Bank
   if(method == CM_FAST && EnableFastBankMode)
   {
      double trailSL;
      if(g_msDirection == 1) trailSL = currentPrice - InpFastBankTrailPoints * point;
      else                   trailSL = currentPrice + InpFastBankTrailPoints * point;
      MoveSL(trailSL, "FAST_BANK_TRAIL");
   }
   // Hybrid
   if(method == CM_HYBRID && EnableHybridCloseMode)
   {
      if(g_msDirection == 1)
      {
         double atrSL = currentPrice - atr * InpATRTrailMultiplier;
         double recentLow = iLow(InpSymbolName, InpExecTF, 1);
         for(int i = 2; i <= MathMin(InpSwingLookback, 5); i++)
         {
            double lo = iLow(InpSymbolName, InpExecTF, i);
            if(lo > recentLow) recentLow = lo;
         }
         double structSL = recentLow - atr * 0.2;
         MoveSL(MathMax(atrSL, structSL), "HYBRID_TRAIL");
      }
      else
      {
         double atrSL = currentPrice + atr * InpATRTrailMultiplier;
         double recentHigh = iHigh(InpSymbolName, InpExecTF, 1);
         for(int i = 2; i <= MathMin(InpSwingLookback, 5); i++)
         {
            double hi = iHigh(InpSymbolName, InpExecTF, i);
            if(hi < recentHigh) recentHigh = hi;
         }
         double structSL = recentHigh + atr * 0.2;
         MoveSL(MathMin(atrSL, structSL), "HYBRID_TRAIL");
      }
   }
}
//+------------------------------------------------------------------+
//| POSITION MANAGEMENT — CheckInvalidationExit                      |
//+------------------------------------------------------------------+
bool CheckInvalidationExit()
{
   if(!EnableInvalidationExit) return(false);
   if(g_featContinuationScore < InpExhaustionThreshold && g_featEntropyScore > InpEntropyHighThreshold)
   {
      LogDecisionEvent("MANAGEMENT", "Invalidation: High entropy + low continuation", g_msCurrentR);
      return(true);
   }
   if(g_featSpeedShort < g_featSpeedLong * 0.2 && g_featVolumePulse < 0.5 && g_msCurrentR < 0.5)
   {
      LogDecisionEvent("MANAGEMENT", "Invalidation: Momentum collapse", g_msCurrentR);
      return(true);
   }
   return(false);
}
//+------------------------------------------------------------------+
//| POSITION MANAGEMENT — CheckTimeStopExit                          |
//+------------------------------------------------------------------+
bool CheckTimeStopExit()
{
   if(!EnableTimeStop) return(false);
   if(g_msBarsInTrade >= InpMaxTradeAgeBars && g_msCurrentR < 1.0)
   {
      LogDecisionEvent("MANAGEMENT", "Time stop: " + IntegerToString(g_msBarsInTrade) + " bars, R=" + DoubleToString(g_msCurrentR,2), g_msCurrentR);
      return(true);
   }
   return(false);
}
//+------------------------------------------------------------------+
//| POSITION MANAGEMENT — Full Close                                 |
//+------------------------------------------------------------------+
void ClosePosition(string reason)
{
   if(g_msActive == 0) return;
   if(!OrderSelect(g_msTicket, SELECT_BY_TICKET)) return;
   double vol = OrderLots();
   RefreshRates();
   double closePrice;
   if(g_msDirection == 1) closePrice = MarketInfo(InpSymbolName, MODE_BID);
   else                   closePrice = MarketInfo(InpSymbolName, MODE_ASK);
   bool result = OrderClose(g_msTicket, vol, closePrice, InpMaxSlippagePoints, clrRed);
   if(result)
   {
      LogDecisionEvent("EXIT", "Full close reason=" + reason, g_msCurrentR);
   }
   else
   {
      if(EnableDebugPrints) Print("DEBUG: Close failed, err=", GetLastError());
   }
}
//+------------------------------------------------------------------+
//| MAIN POSITION MANAGEMENT ENGINE                                  |
//+------------------------------------------------------------------+
void ManagePosition()
{
   if(g_msActive == 0) return;
   // Verify position still exists
   if(!OrderSelect(g_msTicket, SELECT_BY_TICKET) || OrderCloseTime() > 0)
   {
      int newTicket = FindOurTicket();
      if(newTicket > 0)
      {
         g_msTicket = newTicket;
      }
      else
      {
         ResetManagedState();
         return;
      }
   }
   // Update live metrics
   double currentPrice;
   if(g_msDirection == 1) currentPrice = MarketInfo(InpSymbolName, MODE_BID);
   else                   currentPrice = MarketInfo(InpSymbolName, MODE_ASK);
   double pnlPrice = (currentPrice - g_msEntryPrice) * g_msDirection;
   g_msCurrentR = (g_msRiskDistance > 0) ? pnlPrice / g_msRiskDistance : 0;
   if(pnlPrice > g_msMFE) g_msMFE = pnlPrice;
   if(pnlPrice < g_msMAE) g_msMAE = pnlPrice;
   // Update bars in trade
   datetime curBarTime = iTime(InpSymbolName, InpExecTF, 0);
   if(curBarTime > 0 && g_msEntryTime > 0)
      g_msBarsInTrade = (int)((curBarTime - g_msEntryTime) / PeriodSeconds(InpExecTF));
   // Compute MDAE features
   ComputeMDAEFeatures();
   // Method selection with bounded switching
   if(EnableMDAE && EnablePolicySwitching)
   {
      int desired = SelectCloseMethod();
      if(desired != g_msActiveMethod)
      {
         if(g_msPolicySwitchCount < InpMaxPolicySwitches)
         {
            LogDecisionEvent("MDAE_METHOD", "Switch method entropy=" + DoubleToString(g_featEntropyScore,2), g_msCurrentR);
            g_msActiveMethod = desired;
            g_msPolicySwitchCount++;
         }
      }
   }
   // 1) Invalidation exit
   if(CheckInvalidationExit())
   {
      ClosePosition("INVALIDATION");
      return;
   }
   // 2) Time stop
   if(CheckTimeStopExit())
   {
      ClosePosition("TIME_STOP");
      return;
   }
   // 3) CM_EXIT method
   if(g_msActiveMethod == CM_EXIT)
   {
      ClosePosition("CM_EXIT");
      return;
   }
   // 4) Partials
   ApplyPartialClose();
   // 5) Break-even
   ApplyBreakEven();
   // 6) Trailing
   ApplyTrailingLogic();
}
//+------------------------------------------------------------------+
//| LOGGING — LogDecisionEvent                                       |
//+------------------------------------------------------------------+
void LogDecisionEvent(string eventType, string detail, double score)
{
   if(!EnableLogging) return;
   string ts = TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS);
   double spread = CurrentSpreadPoints();
   if(g_logHandle != INVALID_HANDLE)
   {
      string regimeStr = "NO_TRADE";
      if(g_currentRegime == REGIME_TREND_EXPANSION) regimeStr = "TREND";
      else if(g_currentRegime == REGIME_MEAN_REVERSION) regimeStr = "MR";
      string methodStr = "FIXED";
      if(g_msActiveMethod == CM_ATR) methodStr = "ATR";
      else if(g_msActiveMethod == CM_SWING) methodStr = "SWING";
      else if(g_msActiveMethod == CM_FAST) methodStr = "FAST";
      else if(g_msActiveMethod == CM_EXIT) methodStr = "EXIT";
      else if(g_msActiveMethod == CM_HYBRID) methodStr = "HYBRID";
      FileWrite(g_logHandle, ts, InpSymbolName,
         (g_msActive == 1 ? IntegerToString(g_msTicket) : "0"),
         eventType, regimeStr,
         (g_msActive == 1 ? IntegerToString(g_msDirection) : "0"),
         DoubleToString(g_msCurrentR, 3),
         methodStr,
         detail, "",
         DoubleToString(spread, 1), "",
         DoubleToString(score, 3),
         (g_msStopDueSpread == 1 ? "true" : "false"),
         (g_msStopDueSlippage == 1 ? "true" : "false"));
   }
   if(EnableDebugPrints)
      Print("[", eventType, "] ", detail, " R=", DoubleToString(g_msCurrentR,2), " spread=", DoubleToString(spread,1));
}
//+------------------------------------------------------------------+
//| LOGGING — LogTradeSummary                                        |
//+------------------------------------------------------------------+
void LogTradeSummary(string closeType, double profit)
{
   if(!EnableLogging) return;
   string detail = "CloseType=" + closeType +
      " Profit=" + DoubleToString(profit, 2) +
      " MFE=" + DoubleToString((g_msRiskDistance > 0 ? g_msMFE / g_msRiskDistance : 0), 2) + "R" +
      " MAE=" + DoubleToString((g_msRiskDistance > 0 ? g_msMAE / g_msRiskDistance : 0), 2) + "R" +
      " Bars=" + IntegerToString(g_msBarsInTrade) +
      " Switches=" + IntegerToString(g_msPolicySwitchCount) +
      " CompViolations=" + IntegerToString(g_msComplianceViolations);
   if(g_logHandle != INVALID_HANDLE)
   {
      FileWrite(g_logHandle, TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS),
         InpSymbolName, IntegerToString(g_msTicket),
         "EXIT_SUMMARY", "", IntegerToString(g_msDirection),
         DoubleToString(g_msCurrentR, 3), "",
         detail, closeType,
         DoubleToString(CurrentSpreadPoints(), 1), "",
         "0",
         (g_msStopDueSpread == 1 ? "true" : "false"),
         (g_msStopDueSlippage == 1 ? "true" : "false"));
   }
   Print("[TRADE_SUMMARY] ", detail);
}

//+------------------------------------------------------------------+    